/**
 * APIDeIntegraOMercosLib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */

'use strict';

const _request = require('../Http/Client/RequestClient');
const _configuration = require('../configuration');
const _apiHelper = require('../APIHelper');
const _baseController = require('./BaseController');

class APIController {
    /**
     * @todo Add general description for this endpoint
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterStatus(contentType, applicationToken, companyToken, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/token_auth_status';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade Produtos contém tudo o que é necessário para gerenciar os produtos do sistema
     * Mercos como :
     * - Grades de cores e tamanhos
     * - Imagens
     * - Preços distintos
     * - Categoria
     * Para associar deve informar nos atributos `grade_cores` e `grade_tamanhos`(todas as cores
     * e tamanhos disponíveis) como mostra no exemplo de JSON de POST. No caso das imagens,
     * deve usar a entidade `imagens` informando o ID do produto.
     * Quando integrar preços distintos, precisa realizar a integração das `tabelas de preço`. Já
     * a categoria é necessário o vinculo  do ID  no campo `categoria_id`.
     * ### Estrutura de Retorno do GET
     * Campo | Tipo | Descrição |
     * -------------- | -------------- | --------------
     * id | Integer | Identificador único
     * codigo | String: 50 | Código de referência do produto
     * nome | String: 100 | Nome do produto.
     * comissao | Double | Comissão do produto. Ex: 5.0 para 5%. Informe null caso não queira
     * calcular comissões pela Mercos.
     * preco_tabela | Double | Preço deste produto na tabela padrão.
     * preco_minimo | Double | Preço mínimo do produto para o recurso da Rentabilidade (apenas
     * Plano Ouro)
     * ipi | Double | Caso não possua IPI, informe null.
     * tipo_ipi | String: 1 | Tipo do IPI do produto: "P" para percentual, "V" para valor fixo em
     * Reais.
     * st | Double | Percentual de Substituição Tributária do produto. Caso não possua ST,
     * informe null.
     * grade_cores | Lista | Lista de cores (String) em que o produto está disponível. Caso não
     * trabalhe com variação de cores, informe null.
     * grade_tamanhos | Lista | Lista de tamanhos (String) em que o produto está disponível. Caso
     * não trabalhe com variação de tamanhos, informe null.
     * moeda | String: 1 | Moeda do produto: Real ("0"), Dólar ("1") ou Euro ("2").
     * unidade | String: 10 | Unidade de medida do produto, por exemplo "Kg" ou "Cx". Opcional.
     * saldo_estoque | Double: 7 | Saldo de estoque do produto. Valor máximo suportado: 9999999.
     * 99
     * observacoes | String: 500 | Utilize para guardar quaisquer informações que não tenham
     * campos específicos.
     * ultima_alteracao | DateTime | Data e hora da última modificação deste produto na Mercos.
     * excluido | Boolean | Indica se o produto está excluído. Os produtos excluídos não poderão
     * mais ser atualizados.  Após excluir um produto `"excluido": true`, este processo não tem
     * retorno, será necessário criar outro produto.
     * ativo | Boolean | Indica se o produto está ativo. Os produtos inativos podem ser
     * atualizados, inclusive podendo voltar a ser ativos.
     * categoria_id | Integer | Identificador único da categoria relacionada ao produto.
     * codigo_ncm | String | Código do NCM - Nomenclatura Comum do Mercosul, utilizado para
     * cálculo automático do ST.
     * multiplo | Double | Múltiplo de venda do produto.
     * peso_bruto | Double | Peso bruto do produto em kg (com até 3 casas decimais).
     * **Obs.: Ambos produtos excluídos e inativos não serão exibidos em tela para o usuário.**
     *
     * @param {dateTime} alteradoApos Retorna os registros que foram alterados após esta data.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterTodosOsProdutos(alteradoApos,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/produtos';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            alterado_apos: _apiHelper.stringifyDateTime(alteradoApos, 'date'),
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = parsed.map(model =>
                        _baseController.getObjectMapper().mapObject(model, 'ObterTodosOsProdutosResponse'));
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade Produtos contém tudo o que é necessário para gerenciar os produtos do sistema
     * Mercos como :
     * - Grades de cores e tamanhos
     * - Imagens
     * - Preços distintos
     * - Categoria
     * Para associar deve informar nos atributos `grade_cores` e `grade_tamanhos`(todas as cores
     * e tamanhos disponíveis) como mostra no exemplo de JSON de POST. No caso das imagens,
     * deve usar a entidade `imagens` informando o ID do produto.
     * Quando integrar preços distintos, precisa realizar a integração das `tabelas de preço`. Já
     * a categoria é necessário o vinculo  do ID  no campo `categoria_id`.
     * ### Estrutura de Retorno do GET
     * Campo | Tipo | Descrição |
     * -------------- | -------------- | --------------
     * id | Integer | Identificador único
     * codigo | String: 50 | Código de referência do produto
     * nome | String: 100 | Nome do produto.
     * comissao | Double | Comissão do produto. Ex: 5.0 para 5%. Informe null caso não queira
     * calcular comissões pela Mercos.
     * preco_tabela | Double | Preço deste produto na tabela padrão.
     * preco_minimo | Double | Preço mínimo do produto para o recurso da Rentabilidade (apenas
     * Plano Ouro)
     * ipi | Double | Caso não possua IPI, informe null.
     * tipo_ipi | String: 1 | Tipo do IPI do produto: "P" para percentual, "V" para valor fixo em
     * Reais.
     * st | Double | Percentual de Substituição Tributária do produto. Caso não possua ST,
     * informe null.
     * grade_cores | Lista | Lista de cores (String) em que o produto está disponível. Caso não
     * trabalhe com variação de cores, informe null.
     * grade_tamanhos | Lista | Lista de tamanhos (String) em que o produto está disponível. Caso
     * não trabalhe com variação de tamanhos, informe null.
     * moeda | String: 1 | Moeda do produto: Real ("0"), Dólar ("1") ou Euro ("2").
     * unidade | String: 10 | Unidade de medida do produto, por exemplo "Kg" ou "Cx". Opcional.
     * saldo_estoque | Double: 7 | Saldo de estoque do produto. Valor máximo suportado: 9999999.
     * 99
     * observacoes | String: 500 | Utilize para guardar quaisquer informações que não tenham
     * campos específicos.
     * ultima_alteracao | DateTime | Data e hora da última modificação deste produto na Mercos.
     * excluido | Boolean | Indica se o produto está excluído. Os produtos excluídos não poderão
     * mais ser atualizados.  Após excluir um produto `"excluido": true`, este processo não tem
     * retorno, será necessário criar outro produto.
     * ativo | Boolean | Indica se o produto está ativo. Os produtos inativos podem ser
     * atualizados, inclusive podendo voltar a ser ativos.
     * categoria_id | Integer | Identificador único da categoria relacionada ao produto.
     * codigo_ncm | String | Código do NCM - Nomenclatura Comum do Mercosul, utilizado para
     * cálculo automático do ST.
     * multiplo | Double | Múltiplo de venda do produto.
     * peso_bruto | Double | Peso bruto do produto em kg (com até 3 casas decimais).
     * **Obs.: Ambos produtos excluídos e inativos não serão exibidos em tela para o usuário.**
     *
     * @param {double} id ID do Produto no sistema Mercos
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterUmProdutoEspecFico(id, contentType, applicationToken, companyToken, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/produtos/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper()
                .mapObject(parsed, 'ObterUmProdutoEspecFicoResponse');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade Produtos contém tudo o que é necessário para gerenciar os produtos do sistema
     * Mercos como :
     * - Grades de cores e tamanhos
     * - Imagens
     * - Preços distintos
     * - Categoria
     * Para associar deve informar nos atributos `grade_cores` e `grade_tamanhos`(todas as cores
     * e tamanhos disponíveis) como mostra no exemplo de JSON de POST. No caso das imagens,
     * deve usar a entidade `imagens` informando o ID do produto.
     * Quando integrar preços distintos, precisa realizar a integração das `tabelas de preço`. Já
     * a categoria é necessário o vinculo  do ID  no campo `categoria_id`.
     * ### Estrutura de Retorno do GET
     * Campo | Tipo | Descrição |
     * -------------- | -------------- | --------------
     * id | Integer | Identificador único
     * codigo | String: 50 | Código de referência do produto
     * nome | String: 100 | Nome do produto.
     * comissao | Double | Comissão do produto. Ex: 5.0 para 5%. Informe null caso não queira
     * calcular comissões pela Mercos.
     * preco_tabela | Double | Preço deste produto na tabela padrão.
     * preco_minimo | Double | Preço mínimo do produto para o recurso da Rentabilidade (apenas
     * Plano Ouro)
     * ipi | Double | Caso não possua IPI, informe null.
     * tipo_ipi | String: 1 | Tipo do IPI do produto: "P" para percentual, "V" para valor fixo em
     * Reais.
     * st | Double | Percentual de Substituição Tributária do produto. Caso não possua ST,
     * informe null.
     * grade_cores | Lista | Lista de cores (String) em que o produto está disponível. Caso não
     * trabalhe com variação de cores, informe null.
     * grade_tamanhos | Lista | Lista de tamanhos (String) em que o produto está disponível. Caso
     * não trabalhe com variação de tamanhos, informe null.
     * moeda | String: 1 | Moeda do produto: Real ("0"), Dólar ("1") ou Euro ("2").
     * unidade | String: 10 | Unidade de medida do produto, por exemplo "Kg" ou "Cx". Opcional.
     * saldo_estoque | Double: 7 | Saldo de estoque do produto. Valor máximo suportado: 9999999.
     * 99
     * observacoes | String: 500 | Utilize para guardar quaisquer informações que não tenham
     * campos específicos.
     * ultima_alteracao | DateTime | Data e hora da última modificação deste produto na Mercos.
     * excluido | Boolean | Indica se o produto está excluído. Os produtos excluídos não poderão
     * mais ser atualizados.  Após excluir um produto `"excluido": true`, este processo não tem
     * retorno, será necessário criar outro produto.
     * ativo | Boolean | Indica se o produto está ativo. Os produtos inativos podem ser
     * atualizados, inclusive podendo voltar a ser ativos.
     * categoria_id | Integer | Identificador único da categoria relacionada ao produto.
     * codigo_ncm | String | Código do NCM - Nomenclatura Comum do Mercosul, utilizado para
     * cálculo automático do ST.
     * multiplo | Double | Múltiplo de venda do produto.
     * peso_bruto | Double | Peso bruto do produto em kg (com até 3 casas decimais).
     * **Obs.: Ambos produtos excluídos e inativos não serão exibidos em tela para o usuário.**
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {IncluirUmProdutoRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createIncluirUmProduto(contentType, applicationToken, companyToken, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/produtos';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade Produtos contém tudo o que é necessário para gerenciar os produtos do sistema
     * Mercos como :
     * - Grades de cores e tamanhos
     * - Imagens
     * - Preços distintos
     * - Categoria
     * Para associar deve informar nos atributos `grade_cores` e `grade_tamanhos`(todas as cores
     * e tamanhos disponíveis) como mostra no exemplo de JSON de POST. No caso das imagens,
     * deve usar a entidade `imagens` informando o ID do produto.
     * Quando integrar preços distintos, precisa realizar a integração das `tabelas de preço`. Já
     * a categoria é necessário o vinculo  do ID  no campo `categoria_id`.
     * ### Estrutura de Retorno do GET
     * Campo | Tipo | Descrição |
     * -------------- | -------------- | --------------
     * id | Integer | Identificador único
     * codigo | String: 50 | Código de referência do produto
     * nome | String: 100 | Nome do produto.
     * comissao | Double | Comissão do produto. Ex: 5.0 para 5%. Informe null caso não queira
     * calcular comissões pela Mercos.
     * preco_tabela | Double | Preço deste produto na tabela padrão.
     * preco_minimo | Double | Preço mínimo do produto para o recurso da Rentabilidade (apenas
     * Plano Ouro)
     * ipi | Double | Caso não possua IPI, informe null.
     * tipo_ipi | String: 1 | Tipo do IPI do produto: "P" para percentual, "V" para valor fixo em
     * Reais.
     * st | Double | Percentual de Substituição Tributária do produto. Caso não possua ST,
     * informe null.
     * grade_cores | Lista | Lista de cores (String) em que o produto está disponível. Caso não
     * trabalhe com variação de cores, informe null.
     * grade_tamanhos | Lista | Lista de tamanhos (String) em que o produto está disponível. Caso
     * não trabalhe com variação de tamanhos, informe null.
     * moeda | String: 1 | Moeda do produto: Real ("0"), Dólar ("1") ou Euro ("2").
     * unidade | String: 10 | Unidade de medida do produto, por exemplo "Kg" ou "Cx". Opcional.
     * saldo_estoque | Double: 7 | Saldo de estoque do produto. Valor máximo suportado: 9999999.
     * 99
     * observacoes | String: 500 | Utilize para guardar quaisquer informações que não tenham
     * campos específicos.
     * ultima_alteracao | DateTime | Data e hora da última modificação deste produto na Mercos.
     * excluido | Boolean | Indica se o produto está excluído. Os produtos excluídos não poderão
     * mais ser atualizados.  Após excluir um produto `"excluido": true`, este processo não tem
     * retorno, será necessário criar outro produto.
     * ativo | Boolean | Indica se o produto está ativo. Os produtos inativos podem ser
     * atualizados, inclusive podendo voltar a ser ativos.
     * categoria_id | Integer | Identificador único da categoria relacionada ao produto.
     * codigo_ncm | String | Código do NCM - Nomenclatura Comum do Mercosul, utilizado para
     * cálculo automático do ST.
     * multiplo | Double | Múltiplo de venda do produto.
     * peso_bruto | Double | Peso bruto do produto em kg (com até 3 casas decimais).
     * **Obs.: Ambos produtos excluídos e inativos não serão exibidos em tela para o usuário.**
     *
     * @param {double} id ID do Produto no sistema Mercos
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static alterarUmProduto(id, contentType, applicationToken, companyToken, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/produtos/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'AlterarUmProdutoResponse');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Este endpoint ajusta o estoque de um produto no sistema.## Parâmetros do JSON de envio
     * Campo | Tipo | Descrição |
     * ----- | ---- | -----
     * **produto_id**<br><small>(obrigatório)</small>| Integer | Identificador do produto.
     * **novo_saldo**<br><small>(obrigatório)</small>| Double: 7 | Novo saldo de estoque do
     * produto. Após o ajuste de estoque, o saldo do produto ficará igual ao valor informado
     * neste campo. Valor máximo suportado: 9999999.99.
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {AjustarOEstoqueDeProdutoRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static updateAjustarOEstoqueDeProduto(contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/ajustar_estoque';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 422) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'AjustarOEstoqueDeProduto422ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 422,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Este método adiciona uma imagem a um produto específico, mas o produto pode conter várias
     * imagens.
     * É possível escolher entre duas formas de envio:
     * * URL da imagem
     * * Imagem convertida em Base64
     * Caso os dois parâmetros sejam informados o sistema irá considerar apenas a URL da imagem.
     * ### Estrutura de Retorno do GET
     * Esta integração não possui um body JSON no retorno em caso de sucesso, será retornado um
     * HTTP status code 201 e os seguintes headers:
     * Campo | Tipo | Descrição |
     * ---|- | -
     * MeusPedidosID | Integer | Identificador único da imagem na Mercos.
     * MEUSPEDIDOS_QTDE_TOTAL_REGISTROS | Integer | Valor será sempre 0 nesse método.Este método
     * adiciona uma imagem ao produto específico. É possível escolher entre duas formas de envio,
     * URL da imagem ou a imagem convertida em Base64. Caso os dois parâmetros sejam informados o
     * sistema irá considerar apenas a URL da imagem
     * ### Requisição HTTP
     * `POST https://app.mercos.com/api/v1/imagens_produto`
     * ### Parâmetros da URL
     * Campo | Tipo | Descrição |
     * ----- |----- | --
     * **produto_id**<br><small>(obrigatório)</small> | Integer | Identificador único do Produto
     * na Mercos.
     * ordem | Integer | Ordem que as imagens serão exibidas na Mercos. Sendo 1 a imagem
     * principal.
     * imagem_url | String: 500 | URL pública da imagem.
     * imagem_base64 | String | Imagem convertida em Base64.
     * É **obrigatório** informar um dos seguintes campos: `imagem_url` ou `imagem_base64`.
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {object} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createIncluirUmaImagem(contentType, applicationToken, companyToken, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/imagens_produto';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'IncluirUmaImagem412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Representa as demais tabelas de preço disponíveis, além da tabela padrão. Cada produto
     * pode ter um preço diferente em cada tabela de preço.
     * Existem 3 tipos de tabelas:
     * * Preço Livre: o preço dos produtos é informado livremente através da API.
     * * Acréscimo: o preço dos produtos é calculado automaticamente, aplicando um acréscimo
     * sobre o preço padrão (cadastrado na entidade Produto).
     * * Desconto: o preço dos produtos é calculado automaticamente, aplicando um desconto sobre
     * o preço padrão (cadastrado na entidade Produto).
     * -----
     * #### Estrutura de Retorno do GET
     * |       Campo      |     Tipo    | Descrição
     * |
     * |:----------------:|:-----------:|---------------------------------------------------------
     * --------------------------|
     * |        id        |   Integer   | Identificador único
     * |
     * |       nome       | String: 100 | Nome da tabela de preço
     * |
     * |       tipo       |  String: 2  | Tipo da tabela. Valores possíveis: P (preço livre) - A
     * (acrescimo) - D (desconto) |
     * |     acrescimo    |    Float    | Acréscimo a ser aplicado nas tabelas do tipo A
     * |
     * |     desconto     |    Float    | Desconto a ser aplicado nas tabelas do tipo D
     * |
     * |     excluido     |   Boolean   | Indica se a tabela de preço está excluída
     * |
     * | ultima_alteracao |   DateTime  | Data e hora da última modificação desta tabela de preço
     * no Mercos                 |
     *
     * @param {dateTime} alteradoApos Retorna os registros que foram alterados após esta data.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterTodasAsTabelasDePreO(alteradoApos,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/tabelas_preco';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            alterado_apos: _apiHelper.stringifyDateTime(alteradoApos, 'date'),
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = parsed.map(model =>
                        _baseController.getObjectMapper().mapObject(model, 'ObterTodasAsTabelasDePreOResponse'));
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Representa as demais tabelas de preço disponíveis, além da tabela padrão. Cada produto
     * pode ter um preço diferente em cada tabela de preço.
     * Existem 3 tipos de tabelas:
     * * Preço Livre: o preço dos produtos é informado livremente através da API.
     * * Acréscimo: o preço dos produtos é calculado automaticamente, aplicando um acréscimo
     * sobre o preço padrão (cadastrado na entidade Produto).
     * * Desconto: o preço dos produtos é calculado automaticamente, aplicando um desconto sobre
     * o preço padrão (cadastrado na entidade Produto).
     * -----
     * #### Estrutura de Retorno do GET
     * |       Campo      |     Tipo    | Descrição
     * |
     * |:----------------:|:-----------:|---------------------------------------------------------
     * --------------------------|
     * |        id        |   Integer   | Identificador único
     * |
     * |       nome       | String: 100 | Nome da tabela de preço
     * |
     * |       tipo       |  String: 2  | Tipo da tabela. Valores possíveis: P (preço livre) - A
     * (acrescimo) - D (desconto) |
     * |     acrescimo    |    Float    | Acréscimo a ser aplicado nas tabelas do tipo A
     * |
     * |     desconto     |    Float    | Desconto a ser aplicado nas tabelas do tipo D
     * |
     * |     excluido     |   Boolean   | Indica se a tabela de preço está excluída
     * |
     * | ultima_alteracao |   DateTime  | Data e hora da última modificação desta tabela de preço
     * no Mercos                 |
     *
     * @param {double} id ID da Tabela de Preço no sistema Mercos
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterUmaTabelaDePreO(id, contentType, applicationToken, companyToken, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/tabelas_preco/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = parsed.map(model =>
                        _baseController.getObjectMapper().mapObject(model, 'ObterUmaTabelaDePreOResponse'));
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Representa as demais tabelas de preço disponíveis, além da tabela padrão. Cada produto
     * pode ter um preço diferente em cada tabela de preço.
     * Existem 3 tipos de tabelas:
     * * Preço Livre: o preço dos produtos é informado livremente através da API.
     * * Acréscimo: o preço dos produtos é calculado automaticamente, aplicando um acréscimo
     * sobre o preço padrão (cadastrado na entidade Produto).
     * * Desconto: o preço dos produtos é calculado automaticamente, aplicando um desconto sobre
     * o preço padrão (cadastrado na entidade Produto).
     * -----
     * #### Estrutura de Retorno do GET
     * |       Campo      |     Tipo    | Descrição
     * |
     * |:----------------:|:-----------:|---------------------------------------------------------
     * --------------------------|
     * |        id        |   Integer   | Identificador único
     * |
     * |       nome       | String: 100 | Nome da tabela de preço
     * |
     * |       tipo       |  String: 2  | Tipo da tabela. Valores possíveis: P (preço livre) - A
     * (acrescimo) - D (desconto) |
     * |     acrescimo    |    Float    | Acréscimo a ser aplicado nas tabelas do tipo A
     * |
     * |     desconto     |    Float    | Desconto a ser aplicado nas tabelas do tipo D
     * |
     * |     excluido     |   Boolean   | Indica se a tabela de preço está excluída
     * |
     * | ultima_alteracao |   DateTime  | Data e hora da última modificação desta tabela de preço
     * no Mercos                 |
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {IncluirUmaTabelaDePreORequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createIncluirUmaTabelaDePreO(contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/tabelas_preco';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Representa as demais tabelas de preço disponíveis, além da tabela padrão. Cada produto
     * pode ter um preço diferente em cada tabela de preço.
     * Existem 3 tipos de tabelas:
     * * Preço Livre: o preço dos produtos é informado livremente através da API.
     * * Acréscimo: o preço dos produtos é calculado automaticamente, aplicando um acréscimo
     * sobre o preço padrão (cadastrado na entidade Produto).
     * * Desconto: o preço dos produtos é calculado automaticamente, aplicando um desconto sobre
     * o preço padrão (cadastrado na entidade Produto).
     * -----
     * #### Estrutura de Retorno do GET
     * |       Campo      |     Tipo    | Descrição
     * |
     * |:----------------:|:-----------:|---------------------------------------------------------
     * --------------------------|
     * |        id        |   Integer   | Identificador único
     * |
     * |       nome       | String: 100 | Nome da tabela de preço
     * |
     * |       tipo       |  String: 2  | Tipo da tabela. Valores possíveis: P (preço livre) - A
     * (acrescimo) - D (desconto) |
     * |     acrescimo    |    Float    | Acréscimo a ser aplicado nas tabelas do tipo A
     * |
     * |     desconto     |    Float    | Desconto a ser aplicado nas tabelas do tipo D
     * |
     * |     excluido     |   Boolean   | Indica se a tabela de preço está excluída
     * |
     * | ultima_alteracao |   DateTime  | Data e hora da última modificação desta tabela de preço
     * no Mercos                 |
     *
     * @param {double} id ID da Tabela de Preço no sistema Mercos
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {AlterarUmaTabelaDePreORequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static alterarUmaTabelaDePreO(id,
        contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/tabelas_preco/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Esta entidade faz a associação entre os Produtos e as Tabelas de Preço.
     * Representa o preço de um produto em determinada tabela de preço.
     * Cada produto pode ter um preço diferente para cada tabela de preço cadastrada.
     * ----
     * #### Estrutura de Retorno do GET
     * | id               | Integer  | Identificador único
     * |
     * |------------------|----------|------------------------------------------------------------
     * --------------------------------|
     * | preco            | Float    | Preço do produto nesta tabela
     * |
     * | tabela_id        | Integer  | ID da Tabela de Preço. Este deve ser o ID cadastrado no
     * Mercos, e não o ID do seu Sistema. |
     * | produto_id       | Integer  | ID do Produto. Este deve ser o ID cadastrado no Mercos, e
     * não o ID do seu Sistema.         |
     * | excluido         | Boolean  | Indica se o preço está excluído
     * |
     * | ultima_alteracao | DateTime | Data e hora da última modificação desta tabela de preço no
     * Mercos                          |
     *
     * @param {dateTime} alteradoApos Retorna os registros que foram alterados após esta data.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterTodosOsVNculosDeProdutosComTabelasDePreO(alteradoApos,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/produtos_tabela_preco';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            alterado_apos: _apiHelper.stringifyDateTime(alteradoApos, 'date'),
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Esta entidade faz a associação entre os Produtos e as Tabelas de Preço.
     * Representa o preço de um produto em determinada tabela de preço.
     * Cada produto pode ter um preço diferente para cada tabela de preço cadastrada.
     * ----
     * #### Estrutura de Retorno do GET
     * | id               | Integer  | Identificador único
     * |
     * |------------------|----------|------------------------------------------------------------
     * --------------------------------|
     * | preco            | Float    | Preço do produto nesta tabela
     * |
     * | tabela_id        | Integer  | ID da Tabela de Preço. Este deve ser o ID cadastrado no
     * Mercos, e não o ID do seu Sistema. |
     * | produto_id       | Integer  | ID do Produto. Este deve ser o ID cadastrado no Mercos, e
     * não o ID do seu Sistema.         |
     * | excluido         | Boolean  | Indica se o preço está excluído
     * |
     * | ultima_alteracao | DateTime | Data e hora da última modificação desta tabela de preço no
     * Mercos                          |
     *
     * @param {double} id Id do vinculo da tabela de preço com o produto
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterUmVNculoDeProdutoComTabelaDePreO(id,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/produtos_tabela_preco/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Esta entidade faz a associação entre os Produtos e as Tabelas de Preço.
     * Representa o preço de um produto em determinada tabela de preço.
     * Cada produto pode ter um preço diferente para cada tabela de preço cadastrada.
     * ----
     * #### Estrutura de Retorno do GET
     * | id               | Integer  | Identificador único
     * |
     * |------------------|----------|------------------------------------------------------------
     * --------------------------------|
     * | preco            | Float    | Preço do produto nesta tabela
     * |
     * | tabela_id        | Integer  | ID da Tabela de Preço. Este deve ser o ID cadastrado no
     * Mercos, e não o ID do seu Sistema. |
     * | produto_id       | Integer  | ID do Produto. Este deve ser o ID cadastrado no Mercos, e
     * não o ID do seu Sistema.         |
     * | excluido         | Boolean  | Indica se o preço está excluído
     * |
     * | ultima_alteracao | DateTime | Data e hora da última modificação desta tabela de preço no
     * Mercos                          |
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {IncluirUmVNculoDeProdutoComTabelaDePreORequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createIncluirUmVNculoDeProdutoComTabelaDePreO(contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/produtos_tabela_preco';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'IncluirUmVNculoDeProdutoComTabelaDePreO412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Esta entidade faz a associação entre os Produtos e as Tabelas de Preço.
     * Representa o preço de um produto em determinada tabela de preço.
     * Cada produto pode ter um preço diferente para cada tabela de preço cadastrada.
     * ----
     * #### Estrutura de Retorno do GET
     * | id               | Integer  | Identificador único
     * |
     * |------------------|----------|------------------------------------------------------------
     * --------------------------------|
     * | preco            | Float    | Preço do produto nesta tabela
     * |
     * | tabela_id        | Integer  | ID da Tabela de Preço. Este deve ser o ID cadastrado no
     * Mercos, e não o ID do seu Sistema. |
     * | produto_id       | Integer  | ID do Produto. Este deve ser o ID cadastrado no Mercos, e
     * não o ID do seu Sistema.         |
     * | excluido         | Boolean  | Indica se o preço está excluído
     * |
     * | ultima_alteracao | DateTime | Data e hora da última modificação desta tabela de preço no
     * Mercos                          |
     *
     * @param {double} id Id do vinculo da tabela de preço com o produto
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {AlterarUmVNculoDeProdutoComTabelaDePreORequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static alterarUmVNculoDeProdutoComTabelaDePreO(id,
        contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/produtos_tabela_preco/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'AlterarUmVNculoDeProdutoComTabelaDePreO412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade clientes permite incluir, alterar e excluir clientes no Mercos.
     * Nessa entidade, também é possível realizar a configuração especifica sobre as exceções
     * fiscais das configurações de ICMS-ST definas pela integração ou manualmente no sistema
     * Mercos.
     * #### Estrutura de Retorno GET
     * | Campo                | Tipo        | Descrição
     * 
     * 
     * |
     * |----------------------|-------------|-----------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * -----------|
     * | id                   | Integer     | Identificador único
     * 
     * 
     * |
     * | razao_social         | String: 100 | Razão social para pessoa jurídica.Nome do cliente
     * para pessoa física.
     * 
     * |
     * | nome_fantasia        | String: 100 | Nome fantasia (somente pessoa jurídica).
     * 
     * 
     * |
     * | tipo                 | String: 1   | J para pessoa jurídicaF para pessoa física.
     * 
     * 
     * |
     * | cnpj                 | String: 18  | CNPJ para pessoa jurídicaCPF para pessoa física.
     * Apenas números, sem pontuação.
     * 
     * |
     * | inscricao_estadual   | String: 30  | Identificação da inscrição estadual do cliente.
     * 
     * 
     * |
     * | suframa              | String: 20  | Código Suframa para clientes da Zona Franca de
     * Manaus. Caso seja informado, todos os pedidos deste cliente terão IPI zerado (isento).
     * 
     * |
     * | rua                  | String: 100 | Rua do endereço do cliente
     * 
     * 
     * |
     * | numero               | String: 100 | Número do endereço do cliente
     * 
     * 
     * |
     * | complemento          | String: 50  | Informações adicinais do endereço do cliente.
     * 
     * 
     * |
     * | cep                  | String: 9   | Pode ser informado com ou sem hífen.
     * 
     * 
     * |
     * | bairro               | String: 30  | Bairro do cliente
     * 
     * 
     * |
     * | cidade               | String: 50  | Cidade do cliente
     * 
     * 
     * |
     * | estado               | String: 2   | Sigla do Estado.
     * 
     * 
     * |
     * | observacao           | String: 500 | Utilize para guardar quaisquer informações que não
     * tenham campos específicos.
     * 
     * |
     * | emails               | List        | Lista de objetos Email com os emails do cliente. -
     * e-mail (String: 75)
     * 
     * |
     * | telefones            | List        | Lista de objetos Telefone com os telefones do
     * cliente. - numero (String: 30)
     * 
     * |
     * | contatos             | List        | Lista de objetos Contato com os contatos do cliente.
     * - nome (String: 50) - cargo (String: 30) - excluido (Boolean) - emails (List) - telefones
     * (List)
     * |
     * | nome_excecao_fiscal  | String: 20  | Exceção fiscal que identifica o(s) cliente(s)
     * sujeito(s) a esta configuração de ICMS-ST. Ex: “SIMPLES”.
     * 
     * |
     * | segmento_id          | Integer     | Identificador do segmento do cliente para
     * diferenciação em relatórios e políticas comerciais. Ex: 123.
     * 
     * |
     * | rede_id              | Integer     | Identificador da rede do cliente para diferenciação
     * em relatórios. Ex: 456.
     * | bloqueado_b2b        | Boolean     | Indica se o cliente possui bloqueio de acesso ao E-
     * commerce B2B.
     * | excluido             | Boolean     | Indica se o cliente está excluído.
     * 
     * 
     * |
     * | enderecos_adicionais | List        | Lista de objetos EnderecoAdicional do cliente. -
     * cep (String: 9) Pode ser informado com ou sem hífen. - endereco (String: 200) - numero
     * (String: 100) - complemento (String: 200) - bairro (String: 200) - cidade (String: 200) -
     * estado (String: 2) |
     * | ultima_alteracao     | DateTime    | Data e hora da última modificação deste cliente no
     * Mercos.
     * 
     * |
     *
     * @param {dateTime} alteradoApos Retorna os registros que foram alterados após esta data.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterTodosOsClientes(alteradoApos,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/clientes';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            alterado_apos: _apiHelper.stringifyDateTime(alteradoApos, 'date'),
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade clientes permite incluir, alterar e excluir clientes no Mercos.
     * Nessa entidade, também é possível realizar a configuração especifica sobre as exceções
     * fiscais das configurações de ICMS-ST definas pela integração ou manualmente no sistema
     * Mercos.
     * #### Estrutura de Retorno GET
     * | Campo                | Tipo        | Descrição
     * 
     * 
     * |
     * |----------------------|-------------|-----------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * -----------|
     * | id                   | Integer     | Identificador único
     * 
     * 
     * |
     * | razao_social         | String: 100 | Razão social para pessoa jurídica.Nome do cliente
     * para pessoa física.
     * 
     * |
     * | nome_fantasia        | String: 100 | Nome fantasia (somente pessoa jurídica).
     * 
     * 
     * |
     * | tipo                 | String: 1   | J para pessoa jurídicaF para pessoa física.
     * 
     * 
     * |
     * | cnpj                 | String: 18  | CNPJ para pessoa jurídicaCPF para pessoa física.
     * Apenas números, sem pontuação.
     * 
     * |
     * | inscricao_estadual   | String: 30  | Identificação da inscrição estadual do cliente.
     * 
     * 
     * |
     * | suframa              | String: 20  | Código Suframa para clientes da Zona Franca de
     * Manaus. Caso seja informado, todos os pedidos deste cliente terão IPI zerado (isento).
     * 
     * |
     * | rua                  | String: 100 | Rua do endereço do cliente
     * 
     * 
     * |
     * | numero               | String: 100 | Número do endereço do cliente
     * 
     * 
     * |
     * | complemento          | String: 50  | Informações adicinais do endereço do cliente.
     * 
     * 
     * |
     * | cep                  | String: 9   | Pode ser informado com ou sem hífen.
     * 
     * 
     * |
     * | bairro               | String: 30  | Bairro do cliente
     * 
     * 
     * |
     * | cidade               | String: 50  | Cidade do cliente
     * 
     * 
     * |
     * | estado               | String: 2   | Sigla do Estado.
     * 
     * 
     * |
     * | observacao           | String: 500 | Utilize para guardar quaisquer informações que não
     * tenham campos específicos.
     * 
     * |
     * | emails               | List        | Lista de objetos Email com os emails do cliente. -
     * e-mail (String: 75)
     * 
     * |
     * | telefones            | List        | Lista de objetos Telefone com os telefones do
     * cliente. - numero (String: 30)
     * 
     * |
     * | contatos             | List        | Lista de objetos Contato com os contatos do cliente.
     * - nome (String: 50) - cargo (String: 30) - excluido (Boolean) - emails (List) - telefones
     * (List)
     * |
     * | nome_excecao_fiscal  | String: 20  | Exceção fiscal que identifica o(s) cliente(s)
     * sujeito(s) a esta configuração de ICMS-ST. Ex: “SIMPLES”.
     * 
     * |
     * | segmento_id          | Integer     | Identificador do segmento do cliente para
     * diferenciação em relatórios e políticas comerciais. Ex: 123.
     * 
     * |
     * | rede_id              | Integer     | Identificador da rede do cliente para diferenciação
     * em relatórios. Ex: 456.
     * | bloqueado_b2b        | Boolean     | Indica se o cliente possui bloqueio de acesso ao E-
     * commerce B2B.
     * | excluido             | Boolean     | Indica se o cliente está excluído.
     * 
     * 
     * |
     * | enderecos_adicionais | List        | Lista de objetos EnderecoAdicional do cliente. -
     * cep (String: 9) Pode ser informado com ou sem hífen. - endereco (String: 200) - numero
     * (String: 100) - complemento (String: 200) - bairro (String: 200) - cidade (String: 200) -
     * estado (String: 2) |
     * | ultima_alteracao     | DateTime    | Data e hora da última modificação deste cliente no
     * Mercos.
     * 
     * |
     *
     * @param {double} id ID do cliente no sistema Mercos
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterUmClienteEspecFico(id, contentType, applicationToken, companyToken, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/clientes/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade clientes permite incluir, alterar e excluir clientes no Mercos.
     * Nessa entidade, também é possível realizar a configuração especifica sobre as exceções
     * fiscais das configurações de ICMS-ST definas pela integração ou manualmente no sistema
     * Mercos.
     * #### Estrutura de Retorno GET
     * | Campo                | Tipo        | Descrição
     * 
     * 
     * |
     * |----------------------|-------------|-----------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * -----------|
     * | id                   | Integer     | Identificador único
     * 
     * 
     * |
     * | razao_social         | String: 100 | Razão social para pessoa jurídica.Nome do cliente
     * para pessoa física.
     * 
     * |
     * | nome_fantasia        | String: 100 | Nome fantasia (somente pessoa jurídica).
     * 
     * 
     * |
     * | tipo                 | String: 1   | J para pessoa jurídicaF para pessoa física.
     * 
     * 
     * |
     * | cnpj                 | String: 18  | CNPJ para pessoa jurídicaCPF para pessoa física.
     * Apenas números, sem pontuação.
     * 
     * |
     * | inscricao_estadual   | String: 30  | Identificação da inscrição estadual do cliente.
     * 
     * 
     * |
     * | suframa              | String: 20  | Código Suframa para clientes da Zona Franca de
     * Manaus. Caso seja informado, todos os pedidos deste cliente terão IPI zerado (isento).
     * 
     * |
     * | rua                  | String: 100 | Rua do endereço do cliente
     * 
     * 
     * |
     * | numero               | String: 100 | Número do endereço do cliente
     * 
     * 
     * |
     * | complemento          | String: 50  | Informações adicinais do endereço do cliente.
     * 
     * 
     * |
     * | cep                  | String: 9   | Pode ser informado com ou sem hífen.
     * 
     * 
     * |
     * | bairro               | String: 30  | Bairro do cliente
     * 
     * 
     * |
     * | cidade               | String: 50  | Cidade do cliente
     * 
     * 
     * |
     * | estado               | String: 2   | Sigla do Estado.
     * 
     * 
     * |
     * | observacao           | String: 500 | Utilize para guardar quaisquer informações que não
     * tenham campos específicos.
     * 
     * |
     * | emails               | List        | Lista de objetos Email com os emails do cliente. -
     * e-mail (String: 75)
     * 
     * |
     * | telefones            | List        | Lista de objetos Telefone com os telefones do
     * cliente. - numero (String: 30)
     * 
     * |
     * | contatos             | List        | Lista de objetos Contato com os contatos do cliente.
     * - nome (String: 50) - cargo (String: 30) - excluido (Boolean) - emails (List) - telefones
     * (List)
     * |
     * | nome_excecao_fiscal  | String: 20  | Exceção fiscal que identifica o(s) cliente(s)
     * sujeito(s) a esta configuração de ICMS-ST. Ex: “SIMPLES”.
     * 
     * |
     * | segmento_id          | Integer     | Identificador do segmento do cliente para
     * diferenciação em relatórios e políticas comerciais. Ex: 123.
     * 
     * |
     * | rede_id              | Integer     | Identificador da rede do cliente para diferenciação
     * em relatórios. Ex: 456.
     * | bloqueado_b2b        | Boolean     | Indica se o cliente possui bloqueio de acesso ao E-
     * commerce B2B.
     * | excluido             | Boolean     | Indica se o cliente está excluído.
     * 
     * 
     * |
     * | enderecos_adicionais | List        | Lista de objetos EnderecoAdicional do cliente. -
     * cep (String: 9) Pode ser informado com ou sem hífen. - endereco (String: 200) - numero
     * (String: 100) - complemento (String: 200) - bairro (String: 200) - cidade (String: 200) -
     * estado (String: 2) |
     * | ultima_alteracao     | DateTime    | Data e hora da última modificação deste cliente no
     * Mercos.
     * 
     * |
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {IncluirUmClienteRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createIncluirUmCliente(contentType, applicationToken, companyToken, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/clientes';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'IncluirUmCliente412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade clientes permite incluir, alterar e excluir clientes no Mercos.
     * Nessa entidade, também é possível realizar a configuração especifica sobre as exceções
     * fiscais das configurações de ICMS-ST definas pela integração ou manualmente no sistema
     * Mercos.
     * #### Estrutura de Retorno GET
     * | Campo                | Tipo        | Descrição
     * 
     * 
     * |
     * |----------------------|-------------|-----------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * -----------|
     * | id                   | Integer     | Identificador único
     * 
     * 
     * |
     * | razao_social         | String: 100 | Razão social para pessoa jurídica.Nome do cliente
     * para pessoa física.
     * 
     * |
     * | nome_fantasia        | String: 100 | Nome fantasia (somente pessoa jurídica).
     * 
     * 
     * |
     * | tipo                 | String: 1   | J para pessoa jurídicaF para pessoa física.
     * 
     * 
     * |
     * | cnpj                 | String: 18  | CNPJ para pessoa jurídicaCPF para pessoa física.
     * Apenas números, sem pontuação.
     * 
     * |
     * | inscricao_estadual   | String: 30  | Identificação da inscrição estadual do cliente.
     * 
     * 
     * |
     * | suframa              | String: 20  | Código Suframa para clientes da Zona Franca de
     * Manaus. Caso seja informado, todos os pedidos deste cliente terão IPI zerado (isento).
     * 
     * |
     * | rua                  | String: 100 | Rua do endereço do cliente
     * 
     * 
     * |
     * | numero               | String: 100 | Número do endereço do cliente
     * 
     * 
     * |
     * | complemento          | String: 50  | Informações adicinais do endereço do cliente.
     * 
     * 
     * |
     * | cep                  | String: 9   | Pode ser informado com ou sem hífen.
     * 
     * 
     * |
     * | bairro               | String: 30  | Bairro do cliente
     * 
     * 
     * |
     * | cidade               | String: 50  | Cidade do cliente
     * 
     * 
     * |
     * | estado               | String: 2   | Sigla do Estado.
     * 
     * 
     * |
     * | observacao           | String: 500 | Utilize para guardar quaisquer informações que não
     * tenham campos específicos.
     * 
     * |
     * | emails               | List        | Lista de objetos Email com os emails do cliente. -
     * e-mail (String: 75)
     * 
     * |
     * | telefones            | List        | Lista de objetos Telefone com os telefones do
     * cliente. - numero (String: 30)
     * 
     * |
     * | contatos             | List        | Lista de objetos Contato com os contatos do cliente.
     * - nome (String: 50) - cargo (String: 30) - excluido (Boolean) - emails (List) - telefones
     * (List)
     * |
     * | nome_excecao_fiscal  | String: 20  | Exceção fiscal que identifica o(s) cliente(s)
     * sujeito(s) a esta configuração de ICMS-ST. Ex: “SIMPLES”.
     * 
     * |
     * | segmento_id          | Integer     | Identificador do segmento do cliente para
     * diferenciação em relatórios e políticas comerciais. Ex: 123.
     * 
     * |
     * | rede_id              | Integer     | Identificador da rede do cliente para diferenciação
     * em relatórios. Ex: 456.
     * | bloqueado_b2b        | Boolean     | Indica se o cliente possui bloqueio de acesso ao E-
     * commerce B2B.
     * | excluido             | Boolean     | Indica se o cliente está excluído.
     * 
     * 
     * |
     * | enderecos_adicionais | List        | Lista de objetos EnderecoAdicional do cliente. -
     * cep (String: 9) Pode ser informado com ou sem hífen. - endereco (String: 200) - numero
     * (String: 100) - complemento (String: 200) - bairro (String: 200) - cidade (String: 200) -
     * estado (String: 2) |
     * | ultima_alteracao     | DateTime    | Data e hora da última modificação deste cliente no
     * Mercos.
     * 
     * |
     *
     * @param {double} id ID do cliente no sistema Mercos
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {AlterarUmClienteRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static alterarUmCliente(id, contentType, applicationToken, companyToken, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/clientes/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'AlterarUmCliente412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade redes permite incluir, alterar e excluir redes que um cliente pertence, no
     * Mercos.
     * #### Estrutura de Retorno GET
     * | Campo            | Tipo       | Descrição
     * |
     * |------------------|------------|----------------------------------------------------------
     * ----|
     * | id               | Integer    | Identificador único
     * |
     * | nome             | String: 50 | Nome da rede
     * |
     * | ultima_alteracao | DateTime   | Data e hora da última modificação desta rede na Mercos
     * |
     * | excluido         | Boolean    | Indica se a rede está excluída
     * |
     *
     * @param {dateTime} alteradoApos Retorna os registros que foram alterados após esta data.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterTodasAsRedes(alteradoApos,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/redes';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            alterado_apos: _apiHelper.stringifyDateTime(alteradoApos, 'date'),
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade redes permite incluir, alterar e excluir redes que um cliente pertence, no
     * Mercos.
     * #### Estrutura de Retorno GET
     * | Campo            | Tipo       | Descrição
     * |
     * |------------------|------------|----------------------------------------------------------
     * ----|
     * | id               | Integer    | Identificador único
     * |
     * | nome             | String: 50 | Nome da rede
     * |
     * | ultima_alteracao | DateTime   | Data e hora da última modificação desta rede na Mercos
     * |
     * | excluido         | Boolean    | Indica se a rede está excluída
     * |
     *
     * @param {double} id ID da rede no sistema Mercos
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterUmaRedeEspecFica(id, contentType, applicationToken, companyToken, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/redes/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade redes permite incluir, alterar e excluir redes que um cliente pertence, no
     * Mercos.
     * #### Estrutura de Retorno GET
     * | Campo            | Tipo       | Descrição
     * |
     * |------------------|------------|----------------------------------------------------------
     * ----|
     * | id               | Integer    | Identificador único
     * |
     * | nome             | String: 50 | Nome da rede
     * |
     * | ultima_alteracao | DateTime   | Data e hora da última modificação desta rede na Mercos
     * |
     * | excluido         | Boolean    | Indica se a rede está excluída
     * |
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {IncluirUmaNovaRedeRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createIncluirUmaNovaRede(contentType, applicationToken, companyToken, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/redes';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'IncluirUmaNovaRede412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade redes permite incluir, alterar e excluir redes que um cliente pertence, no
     * Mercos.
     * #### Estrutura de Retorno GET
     * | Campo            | Tipo       | Descrição
     * |
     * |------------------|------------|----------------------------------------------------------
     * ----|
     * | id               | Integer    | Identificador único
     * |
     * | nome             | String: 50 | Nome da rede
     * |
     * | ultima_alteracao | DateTime   | Data e hora da última modificação desta rede na Mercos
     * |
     * | excluido         | Boolean    | Indica se a rede está excluída
     * |
     *
     * @param {double} id ID da rede no sistema Mercos
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {AlterarUmaRedeExistenteRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static alterarUmaRedeExistente(id,
        contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/redes/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'AlterarUmaRedeExistente412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade segmentos permite incluir, alterar e excluir os segmentos de clientes no Mercos.
     * #### Estrutura de Retorno GET
     * | Campo            | Tipo       | Descrição
     * |
     * |------------------|------------|----------------------------------------------------------
     * --------|
     * | id               | Integer    | Identificador único
     * |
     * | nome             | String: 50 | Nome do segmento
     * |
     * | ultima_alteracao | DateTime   | Data e hora da última modificação deste segmento na
     * Merocs       |
     * | excluido         | Boolean    | Indica se o segmento está excluída
     * |
     *
     * @param {dateTime} alteradoApos Retorna os registros que foram alterados após esta data.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterTodosOsSegmentos(alteradoApos,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/segmentos';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            alterado_apos: _apiHelper.stringifyDateTime(alteradoApos, 'date'),
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade segmentos permite incluir, alterar e excluir os segmentos de clientes no Mercos.
     * #### Estrutura de Retorno GET
     * | Campo            | Tipo       | Descrição
     * |
     * |------------------|------------|----------------------------------------------------------
     * --------|
     * | id               | Integer    | Identificador único
     * |
     * | nome             | String: 50 | Nome do segmento
     * |
     * | ultima_alteracao | DateTime   | Data e hora da última modificação deste segmento na
     * Merocs       |
     * | excluido         | Boolean    | Indica se o segmento está excluída
     * |
     *
     * @param {double} id ID do segmento no sistema Mercos
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterUmSegmento(id, contentType, applicationToken, companyToken, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/segmentos/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade segmentos permite incluir, alterar e excluir os segmentos de clientes no Mercos.
     * #### Estrutura de Retorno GET
     * | Campo            | Tipo       | Descrição
     * |
     * |------------------|------------|----------------------------------------------------------
     * --------|
     * | id               | Integer    | Identificador único
     * |
     * | nome             | String: 50 | Nome do segmento
     * |
     * | ultima_alteracao | DateTime   | Data e hora da última modificação deste segmento na
     * Merocs       |
     * | excluido         | Boolean    | Indica se o segmento está excluída
     * |
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {IncluirUmSegmentoRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createIncluirUmSegmento(contentType, applicationToken, companyToken, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/segmentos';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'IncluirUmSegmento412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade segmentos permite incluir, alterar e excluir os segmentos de clientes no Mercos.
     * #### Estrutura de Retorno GET
     * | Campo            | Tipo       | Descrição
     * |
     * |------------------|------------|----------------------------------------------------------
     * --------|
     * | id               | Integer    | Identificador único
     * |
     * | nome             | String: 50 | Nome do segmento
     * |
     * | ultima_alteracao | DateTime   | Data e hora da última modificação deste segmento na
     * Merocs       |
     * | excluido         | Boolean    | Indica se o segmento está excluída
     * |
     *
     * @param {double} id ID do segmento no sistema Mercos
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {AlterarUmSegmentoExistenteRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static alterarUmSegmentoExistente(id,
        contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/segmentos/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'AlterarUmSegmentoExistente412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade tags de clientes permite incluir, alterar e excluir as tags utilizadas para o
     * agrupamento de clientes no Mercos.
     * O limite máximo de tags que podem ser cadastradas é 200.
     * #### Estrutura de Retorno GET
     * | Campo            | Tipo       | Descrição
     * |
     * |------------------|------------|----------------------------------------------------------
     * --------|
     * | id               | Integer    | Identificador único
     * |
     * | nome             | String: 50 | Nome da tag
     * |
     * | ultima_alteracao | DateTime   | Data e hora da última modificação desta tag na Mercos
     * |
     * | excluido         | Boolean    | Indica se a tag está excluída
     * |
     *
     * @param {dateTime} alteradoApos Retorna os registros que foram alterados após esta data.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterTodasAsTags(alteradoApos,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/tags_de_clientes';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            alterado_apos: _apiHelper.stringifyDateTime(alteradoApos, 'date'),
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade tags de clientes permite incluir, alterar e excluir as tags utilizadas para o
     * agrupamento de clientes no Mercos.
     * O limite máximo de tags que podem ser cadastradas é 200.
     * #### Estrutura de Retorno GET
     * | Campo            | Tipo       | Descrição
     * |
     * |------------------|------------|----------------------------------------------------------
     * --------|
     * | id               | Integer    | Identificador único
     * |
     * | nome             | String: 50 | Nome da tag
     * |
     * | ultima_alteracao | DateTime   | Data e hora da última modificação desta tag na Mercos
     * |
     * | excluido         | Boolean    | Indica se a tag está excluída
     * |
     *
     * @param {double} tagId ID da tag no sistema Mercos.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterUmaTagEspecFica(tagId, contentType, applicationToken, companyToken, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/tags_de_clientes/{tag_id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            tag_id: tagId,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade tags de clientes permite incluir, alterar e excluir as tags utilizadas para o
     * agrupamento de clientes no Mercos.
     * O limite máximo de tags que podem ser cadastradas é 200.
     * #### Estrutura de Retorno GET
     * | Campo            | Tipo       | Descrição
     * |
     * |------------------|------------|----------------------------------------------------------
     * --------|
     * | id               | Integer    | Identificador único
     * |
     * | nome             | String: 50 | Nome da tag
     * |
     * | ultima_alteracao | DateTime   | Data e hora da última modificação desta tag na Mercos
     * |
     * | excluido         | Boolean    | Indica se a tag está excluída
     * |
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {IncluirUmaTagRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createIncluirUmaTag(contentType, applicationToken, companyToken, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/tags_de_clientes';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'IncluirUmaTag412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade tags de clientes permite incluir, alterar e excluir as tags utilizadas para o
     * agrupamento de clientes no Mercos.
     * O limite máximo de tags que podem ser cadastradas é 200.
     * #### Estrutura de Retorno GET
     * | Campo            | Tipo       | Descrição
     * |
     * |------------------|------------|----------------------------------------------------------
     * --------|
     * | id               | Integer    | Identificador único
     * |
     * | nome             | String: 50 | Nome da tag
     * |
     * | ultima_alteracao | DateTime   | Data e hora da última modificação desta tag na Mercos
     * |
     * | excluido         | Boolean    | Indica se a tag está excluída
     * |
     *
     * @param {double} tagId ID da tag no sistema Mercos
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {AlterarUmaTagExistenteRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static alterarUmaTagExistente(tagId,
        contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/tags_de_clientes/{tag_id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            tag_id: tagId,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'AlterarUmaTagExistente412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Este endpoint permite vincular tags à clientes. As tags enviadas substituirão as tags
     * existentes nos clientes informados. Se desejar remover todas as tags de um ou vários
     * clientes, basta enviar a lista de tags ids vazia.
     * #### Parâmetros do JSON de envio
     * | Campo                                      | Tipo             | Descrição
     * 
     * |
     * |--------------------------------------------|------------------|--------------------------
     * -------------------------------------------------------------------------------------------
     * -------------------------------|
     * | clientes_ids(obrigatório)                  | Lista de Integer | Lista de Identificadores
     * únicos dos Clientes do Mercos. Deve conter pelo menos um elemento.
     * |
     * | tags_ids(obrigatório)                      | Lista de Integer | Lista contendo os
     * identificadores únicos das Tags de Clientes do Mercos. Pode ser vazia, se desejar remover
     * todas as tags dos clientes informados. |
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {VincularClienteTagsRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createVincularClienteTags(contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/vincular_tags_a_clientes';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'VincularClienteTags412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade categorias permite incluir, alterar e excluir as categorias de produtos no
     * Mercos.
     * As categorias terão uma estrutura hierárquica de até 3 níveis. Uma categoria não pode ter
     * o mesmo nome de uma categoria irmã.
     * No put da categoria, só é permitido alterar o seu nome e se ela está excluída.
     * #### Estrutura de Retorno GET
     * | Campo            | Tipo        | Descrição
     * |
     * |------------------|-------------|---------------------------------------------------------
     * ------------------|
     * | id               | Integer     | Identificador único
     * |
     * | nome             | String: 100 | Nome da categoria
     * |
     * | categoria_pai_id | Integer     | Só estará presente no retorno quando tiver alguma
     * categoria pai vinculada |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação desta categoria na
     * Mercos               |
     * | excluido         | Boolean     | Indica se a categoria está excluída
     * |
     *
     * @param {dateTime} alteradoApos Retorna os registros que foram alterados após esta data.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterTodasAsCategorias(alteradoApos,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/categorias';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            alterado_apos: _apiHelper.stringifyDateTime(alteradoApos, 'date'),
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade categorias permite incluir, alterar e excluir as categorias de produtos no
     * Mercos.
     * As categorias terão uma estrutura hierárquica de até 3 níveis. Uma categoria não pode ter
     * o mesmo nome de uma categoria irmã.
     * No put da categoria, só é permitido alterar o seu nome e se ela está excluída.
     * #### Estrutura de Retorno GET
     * | Campo            | Tipo        | Descrição
     * |
     * |------------------|-------------|---------------------------------------------------------
     * ------------------|
     * | id               | Integer     | Identificador único
     * |
     * | nome             | String: 100 | Nome da categoria
     * |
     * | categoria_pai_id | Integer     | Só estará presente no retorno quando tiver alguma
     * categoria pai vinculada |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação desta categoria na
     * Mercos               |
     * | excluido         | Boolean     | Indica se a categoria está excluída
     * |
     *
     * @param {double} id ID da categoria no sistema Mercos.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterUmaCategoriaEspecFica(id,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/catgorias/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade categorias permite incluir, alterar e excluir as categorias de produtos no
     * Mercos.
     * As categorias terão uma estrutura hierárquica de até 3 níveis. Uma categoria não pode ter
     * o mesmo nome de uma categoria irmã.
     * No put da categoria, só é permitido alterar o seu nome e se ela está excluída.
     * #### Estrutura de Retorno GET
     * | Campo            | Tipo        | Descrição
     * |
     * |------------------|-------------|---------------------------------------------------------
     * ------------------|
     * | id               | Integer     | Identificador único
     * |
     * | nome             | String: 100 | Nome da categoria
     * |
     * | categoria_pai_id | Integer     | Só estará presente no retorno quando tiver alguma
     * categoria pai vinculada |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação desta categoria na
     * Mercos               |
     * | excluido         | Boolean     | Indica se a categoria está excluída
     * |
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {IncluirUmaNovaCategoriaRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createIncluirUmaNovaCategoria(contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/categorias';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'IncluirUmaNovaCategoria412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade categorias permite incluir, alterar e excluir as categorias de produtos no
     * Mercos.
     * As categorias terão uma estrutura hierárquica de até 3 níveis. Uma categoria não pode ter
     * o mesmo nome de uma categoria irmã.
     * No put da categoria, só é permitido alterar o seu nome e se ela está excluída.
     * #### Estrutura de Retorno GET
     * | Campo            | Tipo        | Descrição
     * |
     * |------------------|-------------|---------------------------------------------------------
     * ------------------|
     * | id               | Integer     | Identificador único
     * |
     * | nome             | String: 100 | Nome da categoria
     * |
     * | categoria_pai_id | Integer     | Só estará presente no retorno quando tiver alguma
     * categoria pai vinculada |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação desta categoria na
     * Mercos               |
     * | excluido         | Boolean     | Indica se a categoria está excluída
     * |
     *
     * @param {double} id ID da categoria no sistema Mercos
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {AlterarUmaCategoriaExistenteRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static alterarUmaCategoriaExistente(id,
        contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/categorias/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'AlterarUmaCategoriaExistente412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade de categorias por cliente permite apenas a inclusão de vínculos entre cliente e
     * categoria.
     * Utilizando este método é possível definir uma ou mais categorias que serão exibidas para
     * um determinado cliente.
     * Todas as demais categorias não estarão disponíveis para clientes que tiverem registros
     * desta configuração.
     * Ao liberar uma categoria pai, todas as categorias filhas já estarão liberadas. Não devem
     * ser informadas na mesma requisição as categorias que possuem alguma relação entre si (pai-
     * filha, avô-neta).
     * Categorias exemplo:
     * - Eletrodomésticos
     * - Linha Branca
     * - Geladeira
     * - Micro-ondas
     * - Linha cinza
     * - Fogão
     * - Ao informar a categoria `eletrodomésticos`, todas as categorias serão liberadas.
     * - Ao informar a categoria `linha branca`, esta categoria e suas subcategorias serão
     * liberadas, assim a categoria `linha cinza` e suas subcategorias não serão liberadas.
     * - Ao informar as categorias `linha branca` e `geladeira` na mesma requisição um erro será
     * retornado informando que `geladeira` não deve ser enviado pois já é liberado pela
     * categoria `linha branca`. O mesmo ocorrerá caso seja enviado `eletrodomésticos` e
     * `geladeira` na mesma requisição
     * #### Parâmetros do JSON de envio
     * | Campo                             | Tipo             | Descrição
     * |
     * |-----------------------------------|------------------|-----------------------------------
     * ---------------------------------------|
     * | cliente_id(obrigatório)           | Integer          | Identificador único do Cliente do
     * Mercos.                          |
     * | categorias_liberadas(obrigatório) | Lista de Integer | Lista contendo os identificadores
     * únicos das Categorias do Mercos. |
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {VincularClienteCategoriaRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createVincularClienteCategoria(contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/clientes_categorias';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'VincularClienteCategoria412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade de categorias por cliente permite apenas a inclusão de vínculos entre cliente e
     * categoria.
     * Utilizando este método é possível definir uma ou mais categorias que serão exibidas para
     * um determinado cliente.
     * Todas as demais categorias não estarão disponíveis para clientes que tiverem registros
     * desta configuração.
     * Ao liberar uma categoria pai, todas as categorias filhas já estarão liberadas. Não devem
     * ser informadas na mesma requisição as categorias que possuem alguma relação entre si (pai-
     * filha, avô-neta).
     * Categorias exemplo:
     * - Eletrodomésticos
     * - Linha Branca
     * - Geladeira
     * - Micro-ondas
     * - Linha cinza
     * - Fogão
     * - Ao informar a categoria `eletrodomésticos`, todas as categorias serão liberadas.
     * - Ao informar a categoria `linha branca`, esta categoria e suas subcategorias serão
     * liberadas, assim a categoria `linha cinza` e suas subcategorias não serão liberadas.
     * - Ao informar as categorias `linha branca` e `geladeira` na mesma requisição um erro será
     * retornado informando que `geladeira` não deve ser enviado pois já é liberado pela
     * categoria `linha branca`. O mesmo ocorrerá caso seja enviado `eletrodomésticos` e
     * `geladeira` na mesma requisição
     * #### Parâmetros do JSON de envio
     * | Campo                             | Tipo             | Descrição
     * |
     * |-----------------------------------|------------------|-----------------------------------
     * ---------------------------------------|
     * | cliente_id(obrigatório)           | Integer          | Identificador único do Cliente do
     * Mercos.                          |
     * | categorias_liberadas(obrigatório) | Lista de Integer | Lista contendo os identificadores
     * únicos das Categorias do Mercos. |
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {LiberarTodasAsCategoriasParaOClienteRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createLiberarTodasAsCategoriasParaOCliente(contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/clientes_categorias/liberar_todas';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'LiberarTodasAsCategoriasParaOCliente412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade tabela de preço por cliente permite que as tabelas de preço sejam vinculadas
     * aos clientes, permitindo a liberação/bloqueio de tabelas de preço para clientes
     * específicos.
     * Utilizando este método é possível definir uma ou mais tabelas de preço que serão exibidas
     * para um determinado cliente.
     * Todas as demais tabelas de preço não estarão disponíveis para clientes que tiverem
     * registros desta configuração.
     * #### Parâmetros do JSON de envio
     * | Campo                          | Tipo             | Descrição
     * 
     * |
     * |--------------------------------|------------------|--------------------------------------
     * -------------------------------------------------------------------------------------------
     * ---------------------------|
     * | cliente_id(obrigatório)        | Integer          | Identificador único do Cliente do
     * Mercos.
     * |
     * | tabelas_liberadas(obrigatório) | Lista de Integer | Lista contendo os identificadores
     * únicos das Tabela de preço do Mercos.O identificador especial ‘0’ é referente a tabela de
     * valor padrão do produto. |
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {VincularClienteTabelaDePreORequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createVincularClienteTabelaDePreO(contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/clientes_tabela_preco';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'VincularClienteTabelaDePreO412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade tabela de preço por cliente permite que as tabelas de preço sejam vinculadas
     * aos clientes, permitindo a liberação/bloqueio de tabelas de preço para clientes
     * específicos.
     * Utilizando este método é possível definir uma ou mais tabelas de preço que serão exibidas
     * para um determinado cliente.
     * Todas as demais tabelas de preço não estarão disponíveis para clientes que tiverem
     * registros desta configuração.
     * #### Parâmetros do JSON de envio
     * | Campo                          | Tipo             | Descrição
     * 
     * |
     * |--------------------------------|------------------|--------------------------------------
     * -------------------------------------------------------------------------------------------
     * ---------------------------|
     * | cliente_id(obrigatório)        | Integer          | Identificador único do Cliente do
     * Mercos.
     * |
     * | tabelas_liberadas(obrigatório) | Lista de Integer | Lista contendo os identificadores
     * únicos das Tabela de preço do Mercos.O identificador especial ‘0’ é referente a tabela de
     * valor padrão do produto. |
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {LiberarTodasAsTabelasDePreOParaOClienteRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createLiberarTodasAsTabelasDePreOParaOCliente(contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/clientes_tabela_preco/liberar_todas';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'LiberarTodasAsTabelasDePreOParaOCliente412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Representa os usuários que tem acesso ao Mercos.
     * Somente podem ser cadastrados através da interface Web do Mercos. A recomendação é que
     * seja criado 1 usuário para cada vendedor cadastrado no Sistema do cliente.
     * O mapeamento entre usuários do Mercos e vendedores do Sistema pode ser feito através do
     * email do vendedor.
     * #### Estrutura de Retorno do GET
     * | Campo            | Tipo        | Descrição
     * |
     * |------------------|-------------|---------------------------------------------------------
     * ---|
     * | id               | Integer     | Identificador único
     * |
     * | nome             | String: 100 | Nome do usuário
     * |
     * | email            | String: 75  | Email do usuário (sempre único no mercos)
     * |
     * | telefone         | String: 15  | Telefone do usuário
     * |
     * | administrador    | Boolean     | Indica se o usuário é Administrador do sistema.
     * |
     * | excluido         | Boolean     | Indica se o usuário está excluído.
     * |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação deste usuário no
     * Mercos. |
     *
     * @param {dateTime} alteradoApos Retorna os registros que foram alterados após esta data.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterTodosOsVendedores(alteradoApos,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/usuarios';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            alterado_apos: _apiHelper.stringifyDateTime(alteradoApos, 'date'),
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Representa os usuários que tem acesso ao Mercos.
     * Somente podem ser cadastrados através da interface Web do Mercos. A recomendação é que
     * seja criado 1 usuário para cada vendedor cadastrado no Sistema do cliente.
     * O mapeamento entre usuários do Mercos e vendedores do Sistema pode ser feito através do
     * email do vendedor.
     * #### Estrutura de Retorno do GET
     * | Campo            | Tipo        | Descrição
     * |
     * |------------------|-------------|---------------------------------------------------------
     * ---|
     * | id               | Integer     | Identificador único
     * |
     * | nome             | String: 100 | Nome do usuário
     * |
     * | email            | String: 75  | Email do usuário (sempre único no mercos)
     * |
     * | telefone         | String: 15  | Telefone do usuário
     * |
     * | administrador    | Boolean     | Indica se o usuário é Administrador do sistema.
     * |
     * | excluido         | Boolean     | Indica se o usuário está excluído.
     * |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação deste usuário no
     * Mercos. |
     *
     * @param {double} id ID do usuário no sistema Mercos
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterUmVendedorEspecFico(id,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/usuarios/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Cada registro dessa entidade contém uma regra que define se um usuário possui ou não
     * acesso a um cliente armazenado no Mercos. O conjunto dessas regras será utilizado para
     * obter a carteira de clientes de cada usuário dentro do Mercos.
     * Não é possível editar um registro desta entidade, porém o sistema Mercos sempre irá
     * respeitar o registro mais recente tratando da liberação de um determinado cliente para um
     * determinado usuário.
     * Por padrão os clientes cadastrados via integração estão bloqueados para todos os usuários
     * com a opção “Limitar acesso aos clientes” selecionada, sendo necessário fazer um POST
     * nesta entidade criando liberações destes clientes para os respectivos usuários.
     * Novos usuários cadastrados na interface da Mercos com a opção “Limitar acesso aos
     * clientes” não tem liberação de acesso para nenhum cliente, sendo necessário fazer um POST
     * nesta entidade criando liberações deste usuário para os respectivos clientes.
     * Caso seja feito um POST criando uma regra de liberação para um usuário com a opção
     * “Acessar todos os Clientes” selecionada, este usuário será automaticamente alterado para a
     * opção “Limitar acesso aos clientes” e a nova regra de liberação será cadastrada.
     * Por padrão clientes cadastrados pela interface do sistema Mercos estão liberados para o
     * usuário que cadastrou estes clientes, mesmo que o usuário esteja com a opção “Limitar
     * acesso aos clientes” selecionada. Caso seja feito um POST bloqueando um cliente para o
     * usuário que o cadastrou, o sistema irá respeitar este bloqueio.
     * Não é possível fazer um bloqueio de cliente para um usuário administrador.
     * Ao atualizar as liberações de clientes para os usuários, não é recomendado enviar POSTs de
     * bloqueio de todos os clientes para todos os usuários e depois enviar as novas liberações,
     * este procedimento seria muito lento e poderia causar problemas na base do cliente e o
     * bloqueio da integração pela Mercos. A forma correta é efetuar primeiro um GET de todos os
     * registros desta entidade e comparar este retorno com as novas permissões definidas no ERP
     * realizando POSTs apenas para os casos de divergência nas liberações.
     * #### Estrutura de Retorno do GET
     * | Campo            | Tipo     | Descrição
     * |
     * |------------------|----------|------------------------------------------------------------
     * -|
     * | cliente_id       | Integer  | Identificador único do Cliente da Mercos.
     * |
     * | usuario_id       | Integer  | Identificador único do Usuário da Mercos.
     * |
     * | liberado         | Boolean  | Representa se o Usuário tem acesso ao Cliente.
     * |
     * | ultima_alteracao | DateTime | Data e hora da última modificação desta categoria no
     * Mercos |
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterTodasAsRegrasDeLiberaO(contentType, applicationToken, companyToken, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/usuarios_clientes';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Cada registro dessa entidade contém uma regra que define se um usuário possui ou não
     * acesso a um cliente armazenado no Mercos. O conjunto dessas regras será utilizado para
     * obter a carteira de clientes de cada usuário dentro do Mercos.
     * Não é possível editar um registro desta entidade, porém o sistema Mercos sempre irá
     * respeitar o registro mais recente tratando da liberação de um determinado cliente para um
     * determinado usuário.
     * Por padrão os clientes cadastrados via integração estão bloqueados para todos os usuários
     * com a opção “Limitar acesso aos clientes” selecionada, sendo necessário fazer um POST
     * nesta entidade criando liberações destes clientes para os respectivos usuários.
     * Novos usuários cadastrados na interface da Mercos com a opção “Limitar acesso aos
     * clientes” não tem liberação de acesso para nenhum cliente, sendo necessário fazer um POST
     * nesta entidade criando liberações deste usuário para os respectivos clientes.
     * Caso seja feito um POST criando uma regra de liberação para um usuário com a opção
     * “Acessar todos os Clientes” selecionada, este usuário será automaticamente alterado para a
     * opção “Limitar acesso aos clientes” e a nova regra de liberação será cadastrada.
     * Por padrão clientes cadastrados pela interface do sistema Mercos estão liberados para o
     * usuário que cadastrou estes clientes, mesmo que o usuário esteja com a opção “Limitar
     * acesso aos clientes” selecionada. Caso seja feito um POST bloqueando um cliente para o
     * usuário que o cadastrou, o sistema irá respeitar este bloqueio.
     * Não é possível fazer um bloqueio de cliente para um usuário administrador.
     * Ao atualizar as liberações de clientes para os usuários, não é recomendado enviar POSTs de
     * bloqueio de todos os clientes para todos os usuários e depois enviar as novas liberações,
     * este procedimento seria muito lento e poderia causar problemas na base do cliente e o
     * bloqueio da integração pela Mercos. A forma correta é efetuar primeiro um GET de todos os
     * registros desta entidade e comparar este retorno com as novas permissões definidas no ERP
     * realizando POSTs apenas para os casos de divergência nas liberações.
     * #### Estrutura de Retorno do GET
     * | Campo            | Tipo     | Descrição
     * |
     * |------------------|----------|------------------------------------------------------------
     * -|
     * | cliente_id       | Integer  | Identificador único do Cliente da Mercos.
     * |
     * | usuario_id       | Integer  | Identificador único do Usuário da Mercos.
     * |
     * | liberado         | Boolean  | Representa se o Usuário tem acesso ao Cliente.
     * |
     * | ultima_alteracao | DateTime | Data e hora da última modificação desta categoria no
     * Mercos |
     *
     * @param {double} id ID do cliente no sistema Mercos
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterAsRegrasParaUmClienteEspecFico(id,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/usuarios_clientes/cliente/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Cada registro dessa entidade contém uma regra que define se um usuário possui ou não
     * acesso a um cliente armazenado no Mercos. O conjunto dessas regras será utilizado para
     * obter a carteira de clientes de cada usuário dentro do Mercos.
     * Não é possível editar um registro desta entidade, porém o sistema Mercos sempre irá
     * respeitar o registro mais recente tratando da liberação de um determinado cliente para um
     * determinado usuário.
     * Por padrão os clientes cadastrados via integração estão bloqueados para todos os usuários
     * com a opção “Limitar acesso aos clientes” selecionada, sendo necessário fazer um POST
     * nesta entidade criando liberações destes clientes para os respectivos usuários.
     * Novos usuários cadastrados na interface da Mercos com a opção “Limitar acesso aos
     * clientes” não tem liberação de acesso para nenhum cliente, sendo necessário fazer um POST
     * nesta entidade criando liberações deste usuário para os respectivos clientes.
     * Caso seja feito um POST criando uma regra de liberação para um usuário com a opção
     * “Acessar todos os Clientes” selecionada, este usuário será automaticamente alterado para a
     * opção “Limitar acesso aos clientes” e a nova regra de liberação será cadastrada.
     * Por padrão clientes cadastrados pela interface do sistema Mercos estão liberados para o
     * usuário que cadastrou estes clientes, mesmo que o usuário esteja com a opção “Limitar
     * acesso aos clientes” selecionada. Caso seja feito um POST bloqueando um cliente para o
     * usuário que o cadastrou, o sistema irá respeitar este bloqueio.
     * Não é possível fazer um bloqueio de cliente para um usuário administrador.
     * Ao atualizar as liberações de clientes para os usuários, não é recomendado enviar POSTs de
     * bloqueio de todos os clientes para todos os usuários e depois enviar as novas liberações,
     * este procedimento seria muito lento e poderia causar problemas na base do cliente e o
     * bloqueio da integração pela Mercos. A forma correta é efetuar primeiro um GET de todos os
     * registros desta entidade e comparar este retorno com as novas permissões definidas no ERP
     * realizando POSTs apenas para os casos de divergência nas liberações.
     * #### Estrutura de Retorno do GET
     * | Campo            | Tipo     | Descrição
     * |
     * |------------------|----------|------------------------------------------------------------
     * -|
     * | cliente_id       | Integer  | Identificador único do Cliente da Mercos.
     * |
     * | usuario_id       | Integer  | Identificador único do Usuário da Mercos.
     * |
     * | liberado         | Boolean  | Representa se o Usuário tem acesso ao Cliente.
     * |
     * | ultima_alteracao | DateTime | Data e hora da última modificação desta categoria no
     * Mercos |
     *
     * @param {double} id ID do usuário no sistema Mercos
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterAsRegrasParaUmUsuRioEspecFico(id,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/usuarios_clientes/usuario/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Cada registro dessa entidade contém uma regra que define se um usuário possui ou não
     * acesso a um cliente armazenado no Mercos. O conjunto dessas regras será utilizado para
     * obter a carteira de clientes de cada usuário dentro do Mercos.
     * Não é possível editar um registro desta entidade, porém o sistema Mercos sempre irá
     * respeitar o registro mais recente tratando da liberação de um determinado cliente para um
     * determinado usuário.
     * Por padrão os clientes cadastrados via integração estão bloqueados para todos os usuários
     * com a opção “Limitar acesso aos clientes” selecionada, sendo necessário fazer um POST
     * nesta entidade criando liberações destes clientes para os respectivos usuários.
     * Novos usuários cadastrados na interface da Mercos com a opção “Limitar acesso aos
     * clientes” não tem liberação de acesso para nenhum cliente, sendo necessário fazer um POST
     * nesta entidade criando liberações deste usuário para os respectivos clientes.
     * Caso seja feito um POST criando uma regra de liberação para um usuário com a opção
     * “Acessar todos os Clientes” selecionada, este usuário será automaticamente alterado para a
     * opção “Limitar acesso aos clientes” e a nova regra de liberação será cadastrada.
     * Por padrão clientes cadastrados pela interface do sistema Mercos estão liberados para o
     * usuário que cadastrou estes clientes, mesmo que o usuário esteja com a opção “Limitar
     * acesso aos clientes” selecionada. Caso seja feito um POST bloqueando um cliente para o
     * usuário que o cadastrou, o sistema irá respeitar este bloqueio.
     * Não é possível fazer um bloqueio de cliente para um usuário administrador.
     * Ao atualizar as liberações de clientes para os usuários, não é recomendado enviar POSTs de
     * bloqueio de todos os clientes para todos os usuários e depois enviar as novas liberações,
     * este procedimento seria muito lento e poderia causar problemas na base do cliente e o
     * bloqueio da integração pela Mercos. A forma correta é efetuar primeiro um GET de todos os
     * registros desta entidade e comparar este retorno com as novas permissões definidas no ERP
     * realizando POSTs apenas para os casos de divergência nas liberações.
     * #### Estrutura de Retorno do GET
     * | Campo            | Tipo     | Descrição
     * |
     * |------------------|----------|------------------------------------------------------------
     * -|
     * | cliente_id       | Integer  | Identificador único do Cliente da Mercos.
     * |
     * | usuario_id       | Integer  | Identificador único do Usuário da Mercos.
     * |
     * | liberado         | Boolean  | Representa se o Usuário tem acesso ao Cliente.
     * |
     * | ultima_alteracao | DateTime | Data e hora da última modificação desta categoria no
     * Mercos |
     *
     * @param {double} id Primeiro o ID do usuário e depois o ID do cliente no sistema Mercos
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterARegraDeUmClienteParaUmUsuRio(id,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/usuarios_clientes/usuario/{id}/cliente/{id]';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Cada registro dessa entidade contém uma regra que define se um usuário possui ou não
     * acesso a um cliente armazenado no Mercos. O conjunto dessas regras será utilizado para
     * obter a carteira de clientes de cada usuário dentro do Mercos.
     * Não é possível editar um registro desta entidade, porém o sistema Mercos sempre irá
     * respeitar o registro mais recente tratando da liberação de um determinado cliente para um
     * determinado usuário.
     * Por padrão os clientes cadastrados via integração estão bloqueados para todos os usuários
     * com a opção “Limitar acesso aos clientes” selecionada, sendo necessário fazer um POST
     * nesta entidade criando liberações destes clientes para os respectivos usuários.
     * Novos usuários cadastrados na interface da Mercos com a opção “Limitar acesso aos
     * clientes” não tem liberação de acesso para nenhum cliente, sendo necessário fazer um POST
     * nesta entidade criando liberações deste usuário para os respectivos clientes.
     * Caso seja feito um POST criando uma regra de liberação para um usuário com a opção
     * “Acessar todos os Clientes” selecionada, este usuário será automaticamente alterado para a
     * opção “Limitar acesso aos clientes” e a nova regra de liberação será cadastrada.
     * Por padrão clientes cadastrados pela interface do sistema Mercos estão liberados para o
     * usuário que cadastrou estes clientes, mesmo que o usuário esteja com a opção “Limitar
     * acesso aos clientes” selecionada. Caso seja feito um POST bloqueando um cliente para o
     * usuário que o cadastrou, o sistema irá respeitar este bloqueio.
     * Não é possível fazer um bloqueio de cliente para um usuário administrador.
     * Ao atualizar as liberações de clientes para os usuários, não é recomendado enviar POSTs de
     * bloqueio de todos os clientes para todos os usuários e depois enviar as novas liberações,
     * este procedimento seria muito lento e poderia causar problemas na base do cliente e o
     * bloqueio da integração pela Mercos. A forma correta é efetuar primeiro um GET de todos os
     * registros desta entidade e comparar este retorno com as novas permissões definidas no ERP
     * realizando POSTs apenas para os casos de divergência nas liberações.
     * #### Estrutura de Retorno do GET
     * | Campo            | Tipo     | Descrição
     * |
     * |------------------|----------|------------------------------------------------------------
     * -|
     * | cliente_id       | Integer  | Identificador único do Cliente da Mercos.
     * |
     * | usuario_id       | Integer  | Identificador único do Usuário da Mercos.
     * |
     * | liberado         | Boolean  | Representa se o Usuário tem acesso ao Cliente.
     * |
     * | ultima_alteracao | DateTime | Data e hora da última modificação desta categoria no
     * Mercos |
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {IncluirUmaRegraDeLiberaORequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createIncluirUmaRegraDeLiberaO(contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/usuarios_clientes';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'IncluirUmaRegraDeLiberaO412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade transportadoras permite incluir, alterar e excluir as transportadoras no Mercos.
     * #### Estrutura de Retorno do GET
     * | Campo                  | Tipo        | Descrição
     * 
     * |
     * |------------------------|-------------|---------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * ------------------------|
     * | id                     | Integer     | Identificador único
     * 
     * |
     * | nome                   | String: 100 | Nome da transportadora
     * 
     * |
     * | cidade                 | String: 50  | Cidade da transportadora
     * 
     * |
     * | estado                 | String: 2   | Sigla do estado da transportadora
     * 
     * |
     * | informacoes_adicionais | String: 500 | Utilize para guardar quaisquer informações que
     * não tenham campos específicos.
     * |
     * | telefones              | List        | Lista de objetos com os telefones da
     * transportadora.numero (String: 30): Número do telefone, com DDD e formatação inclusos.tipo
     * sempre Tid identificador do telefone |
     * | excluido               | Boolean     | Indica se a transportadora está excluída.
     * 
     * |
     * | ultima_alteracao       | DateTime    | Data e hora da última modificação desta
     * transportadora no Mercos.
     *
     * @param {dateTime} alteradoApos Retorna os registros que foram alterados após esta data.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterTodasAsTransportadoras(alteradoApos,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/transportadoras';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            alterado_apos: _apiHelper.stringifyDateTime(alteradoApos, 'date'),
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade transportadoras permite incluir, alterar e excluir as transportadoras no Mercos.
     * #### Estrutura de Retorno do GET
     * | Campo                  | Tipo        | Descrição
     * 
     * |
     * |------------------------|-------------|---------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * ------------------------|
     * | id                     | Integer     | Identificador único
     * 
     * |
     * | nome                   | String: 100 | Nome da transportadora
     * 
     * |
     * | cidade                 | String: 50  | Cidade da transportadora
     * 
     * |
     * | estado                 | String: 2   | Sigla do estado da transportadora
     * 
     * |
     * | informacoes_adicionais | String: 500 | Utilize para guardar quaisquer informações que
     * não tenham campos específicos.
     * |
     * | telefones              | List        | Lista de objetos com os telefones da
     * transportadora.numero (String: 30): Número do telefone, com DDD e formatação inclusos.tipo
     * sempre Tid identificador do telefone |
     * | excluido               | Boolean     | Indica se a transportadora está excluída.
     * 
     * |
     * | ultima_alteracao       | DateTime    | Data e hora da última modificação desta
     * transportadora no Mercos.
     *
     * @param {double} id ID da transportadora no sistema Mercos
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterUmaTransportadoraEspecFica(id,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/transportadoras/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade transportadoras permite incluir, alterar e excluir as transportadoras no Mercos.
     * #### Estrutura de Retorno do GET
     * | Campo                  | Tipo        | Descrição
     * 
     * |
     * |------------------------|-------------|---------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * ------------------------|
     * | id                     | Integer     | Identificador único
     * 
     * |
     * | nome                   | String: 100 | Nome da transportadora
     * 
     * |
     * | cidade                 | String: 50  | Cidade da transportadora
     * 
     * |
     * | estado                 | String: 2   | Sigla do estado da transportadora
     * 
     * |
     * | informacoes_adicionais | String: 500 | Utilize para guardar quaisquer informações que
     * não tenham campos específicos.
     * |
     * | telefones              | List        | Lista de objetos com os telefones da
     * transportadora.numero (String: 30): Número do telefone, com DDD e formatação inclusos.tipo
     * sempre Tid identificador do telefone |
     * | excluido               | Boolean     | Indica se a transportadora está excluída.
     * 
     * |
     * | ultima_alteracao       | DateTime    | Data e hora da última modificação desta
     * transportadora no Mercos.
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {IncluirUmaTransportadoraRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createIncluirUmaTransportadora(contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/transportadoras';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'IncluirUmaTransportadora412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade transportadoras permite incluir, alterar e excluir as transportadoras no Mercos.
     * #### Estrutura de Retorno do GET
     * | Campo                  | Tipo        | Descrição
     * 
     * |
     * |------------------------|-------------|---------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * ------------------------|
     * | id                     | Integer     | Identificador único
     * 
     * |
     * | nome                   | String: 100 | Nome da transportadora
     * 
     * |
     * | cidade                 | String: 50  | Cidade da transportadora
     * 
     * |
     * | estado                 | String: 2   | Sigla do estado da transportadora
     * 
     * |
     * | informacoes_adicionais | String: 500 | Utilize para guardar quaisquer informações que
     * não tenham campos específicos.
     * |
     * | telefones              | List        | Lista de objetos com os telefones da
     * transportadora.numero (String: 30): Número do telefone, com DDD e formatação inclusos.tipo
     * sempre Tid identificador do telefone |
     * | excluido               | Boolean     | Indica se a transportadora está excluída.
     * 
     * |
     * | ultima_alteracao       | DateTime    | Data e hora da última modificação desta
     * transportadora no Mercos.
     *
     * @param {double} id ID da transportadora no sistema Mercos
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {AlterarUmaTransportadoraRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static alterarUmaTransportadora(id,
        contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/transportadoras/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'AlterarUmaTransportadora412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Aqui você poderá integrar suas condições de pagamento, por exemplo: “30/60”, “30/60/90”, e
     * outras.
     * Esta entidade é opcional. Caso você não integre esta informação, será utilizado um campo
     * de texto livre na Condição de Pagamento dos pedidos. O vendedor poderá preencher qualquer
     * valor.
     * Também é possível definir um valor mínimo para cada condição de pagamento, desta forma a
     * condição só estará disponível caso o valor total do pedido seja igual ou maior ao valor
     * mínimo daquela condição.
     * #### Estrutura de Retorno do GET
     * | Campo            | Tipo        | Descrição
     * |
     * |------------------|-------------|---------------------------------------------------------
     * --------------------------------------------|
     * | id               | Integer     | Identificador único
     * |
     * | nome             | String: 100 | Nome da condição de pagamento. Ex: “A vista”.
     * |
     * | valor_minimo     | Double      | Valor mínimo do pedido (sem IPI e ICMS-ST) para que
     * esta condição de pagamento possa ser utilizada. |
     * | excluido         | Boolean     | Indica se a condição de pagamento está excluída.
     * |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação desta condição de
     * pagamento no Mercos.                            |
     *
     * @param {dateTime} alteradoApos Retorna os registros que foram alterados após esta data.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterTodasAsCondiEsDePagamento(alteradoApos,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/condicoes_pagamento';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            alterado_apos: _apiHelper.stringifyDateTime(alteradoApos, 'date'),
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Aqui você poderá integrar suas condições de pagamento, por exemplo: “30/60”, “30/60/90”, e
     * outras.
     * Esta entidade é opcional. Caso você não integre esta informação, será utilizado um campo
     * de texto livre na Condição de Pagamento dos pedidos. O vendedor poderá preencher qualquer
     * valor.
     * Também é possível definir um valor mínimo para cada condição de pagamento, desta forma a
     * condição só estará disponível caso o valor total do pedido seja igual ou maior ao valor
     * mínimo daquela condição.
     * #### Estrutura de Retorno do GET
     * | Campo            | Tipo        | Descrição
     * |
     * |------------------|-------------|---------------------------------------------------------
     * --------------------------------------------|
     * | id               | Integer     | Identificador único
     * |
     * | nome             | String: 100 | Nome da condição de pagamento. Ex: “A vista”.
     * |
     * | valor_minimo     | Double      | Valor mínimo do pedido (sem IPI e ICMS-ST) para que
     * esta condição de pagamento possa ser utilizada. |
     * | excluido         | Boolean     | Indica se a condição de pagamento está excluída.
     * |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação desta condição de
     * pagamento no Mercos.                            |
     *
     * @param {double} id ID da condição de pagamento no sistema Mercos.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterUmaCondiODePagamento(id,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/condicoes_pagamento/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Aqui você poderá integrar suas condições de pagamento, por exemplo: “30/60”, “30/60/90”, e
     * outras.
     * Esta entidade é opcional. Caso você não integre esta informação, será utilizado um campo
     * de texto livre na Condição de Pagamento dos pedidos. O vendedor poderá preencher qualquer
     * valor.
     * Também é possível definir um valor mínimo para cada condição de pagamento, desta forma a
     * condição só estará disponível caso o valor total do pedido seja igual ou maior ao valor
     * mínimo daquela condição.
     * #### Estrutura de Retorno do GET
     * | Campo            | Tipo        | Descrição
     * |
     * |------------------|-------------|---------------------------------------------------------
     * --------------------------------------------|
     * | id               | Integer     | Identificador único
     * |
     * | nome             | String: 100 | Nome da condição de pagamento. Ex: “A vista”.
     * |
     * | valor_minimo     | Double      | Valor mínimo do pedido (sem IPI e ICMS-ST) para que
     * esta condição de pagamento possa ser utilizada. |
     * | excluido         | Boolean     | Indica se a condição de pagamento está excluída.
     * |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação desta condição de
     * pagamento no Mercos.                            |
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {IncluirUmaCondiODePagamentoRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createIncluirUmaCondiODePagamento(contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/condicoes_pagamento';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'IncluirUmaCondiODePagamento412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Aqui você poderá integrar suas condições de pagamento, por exemplo: “30/60”, “30/60/90”, e
     * outras.
     * Esta entidade é opcional. Caso você não integre esta informação, será utilizado um campo
     * de texto livre na Condição de Pagamento dos pedidos. O vendedor poderá preencher qualquer
     * valor.
     * Também é possível definir um valor mínimo para cada condição de pagamento, desta forma a
     * condição só estará disponível caso o valor total do pedido seja igual ou maior ao valor
     * mínimo daquela condição.
     * #### Estrutura de Retorno do GET
     * | Campo            | Tipo        | Descrição
     * |
     * |------------------|-------------|---------------------------------------------------------
     * --------------------------------------------|
     * | id               | Integer     | Identificador único
     * |
     * | nome             | String: 100 | Nome da condição de pagamento. Ex: “A vista”.
     * |
     * | valor_minimo     | Double      | Valor mínimo do pedido (sem IPI e ICMS-ST) para que
     * esta condição de pagamento possa ser utilizada. |
     * | excluido         | Boolean     | Indica se a condição de pagamento está excluída.
     * |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação desta condição de
     * pagamento no Mercos.                            |
     *
     * @param {double} id ID da condição de pagamento no sistema Mercos.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {AlterarUmaCondiODePagamentoRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static alterarUmaCondiODePagamento(id,
        contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/condicoes_pagamento/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'AlterarUmaCondiODePagamento412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade de condições de pagamento por cliente permite apenas a inclusão de vínculos
     * entre cliente e condição de pagamento.
     * Utilizando este método é possível definir uma ou mais condições de pagamento que serão
     * exibidas para um determinado cliente.
     * Todas as demais condições de pagamento não estarão disponíveis para ele.
     * #### Parâmetros do JSON de envio
     * | Campo                                      | Tipo             | Descrição
     * |
     * |--------------------------------------------|------------------|--------------------------
     * ------------------------------------------------------------|
     * | cliente_id(obrigatório)                    | Integer          | Identificador único do
     * Cliente do Mercos.                                      |
     * | condicoes_pagamento_liberadas(obrigatório) | Lista de Integer | Lista contendo os
     * identificadores únicos das Condições de Pagamento do Mercos. |
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {VincularClienteCondiODePagamentoRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createVincularClienteCondiODePagamento(contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/clientes_condicoes_pagamento';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'VincularClienteCondiODePagamento412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade de condições de pagamento por cliente permite apenas a inclusão de vínculos
     * entre cliente e condição de pagamento.
     * Utilizando este método é possível definir uma ou mais condições de pagamento que serão
     * exibidas para um determinado cliente.
     * Todas as demais condições de pagamento não estarão disponíveis para ele.
     * #### Parâmetros do JSON de envio
     * | Campo                                      | Tipo             | Descrição
     * |
     * |--------------------------------------------|------------------|--------------------------
     * ------------------------------------------------------------|
     * | cliente_id(obrigatório)                    | Integer          | Identificador único do
     * Cliente do Mercos.                                      |
     * | condicoes_pagamento_liberadas(obrigatório) | Lista de Integer | Lista contendo os
     * identificadores únicos das Condições de Pagamento do Mercos. |
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {LiberarTodasAsCondiEsDePagamentoParaOClienteRequest} body TODO: type description
     * here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createLiberarTodasAsCondiEsDePagamentoParaOCliente(contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/clientes_condicoes_pagamento/liberar_todas';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'LiberarTodasAsCondiEsDePagamentoParaOCliente412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Aqui você poderá integrar suas formas de pagamento, por exemplo “Boleto”, “Cheque”, e
     * outras.
     * Esta entidade é opcional. Caso você não integre esta informação, o campo Forma de
     * Pagamento não irá aparecer nos pedidos.
     * #### Estrutura de Retorno do GET
     * | Campo            | Tipo        | Descrição
     * |
     * |------------------|-------------|---------------------------------------------------------
     * --------------|
     * | id               | Integer     | Identificador único
     * |
     * | nome             | String: 100 | Nome da forma de pagamento
     * |
     * | excluido         | Boolean     | Indica se a forma de pagamento está excluída.
     * |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação desta forma de
     * pagamento no Mercos. |
     *
     * @param {dateTime} alteradoApos Retorna os registros que foram alterados após esta data.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterTodasAsFormasDePagamento(alteradoApos,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/formas_pagamento';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            alterado_apos: _apiHelper.stringifyDateTime(alteradoApos, 'date'),
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Aqui você poderá integrar suas formas de pagamento, por exemplo “Boleto”, “Cheque”, e
     * outras.
     * Esta entidade é opcional. Caso você não integre esta informação, o campo Forma de
     * Pagamento não irá aparecer nos pedidos.
     * #### Estrutura de Retorno do GET
     * | Campo            | Tipo        | Descrição
     * |
     * |------------------|-------------|---------------------------------------------------------
     * --------------|
     * | id               | Integer     | Identificador único
     * |
     * | nome             | String: 100 | Nome da forma de pagamento
     * |
     * | excluido         | Boolean     | Indica se a forma de pagamento está excluída.
     * |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação desta forma de
     * pagamento no Mercos. |
     *
     * @param {double} id ID da forma de pagamento no sistema Mercos.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterUmaFormaDePagamentoEspecFica(id,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/formas_pagamento/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Aqui você poderá integrar suas formas de pagamento, por exemplo “Boleto”, “Cheque”, e
     * outras.
     * Esta entidade é opcional. Caso você não integre esta informação, o campo Forma de
     * Pagamento não irá aparecer nos pedidos.
     * #### Estrutura de Retorno do GET
     * | Campo            | Tipo        | Descrição
     * |
     * |------------------|-------------|---------------------------------------------------------
     * --------------|
     * | id               | Integer     | Identificador único
     * |
     * | nome             | String: 100 | Nome da forma de pagamento
     * |
     * | excluido         | Boolean     | Indica se a forma de pagamento está excluída.
     * |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação desta forma de
     * pagamento no Mercos. |
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {IncluirUmaFormaDePagamentoRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createIncluirUmaFormaDePagamento(contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/formas_pagamento';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'IncluirUmaFormaDePagamento412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Aqui você poderá integrar suas formas de pagamento, por exemplo “Boleto”, “Cheque”, e
     * outras.
     * Esta entidade é opcional. Caso você não integre esta informação, o campo Forma de
     * Pagamento não irá aparecer nos pedidos.
     * #### Estrutura de Retorno do GET
     * | Campo            | Tipo        | Descrição
     * |
     * |------------------|-------------|---------------------------------------------------------
     * --------------|
     * | id               | Integer     | Identificador único
     * |
     * | nome             | String: 100 | Nome da forma de pagamento
     * |
     * | excluido         | Boolean     | Indica se a forma de pagamento está excluída.
     * |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação desta forma de
     * pagamento no Mercos. |
     *
     * @param {double} id ID da forma de pagamento no sistema Mercos.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {AlterarUmaFormaDePagamentoRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static alterarUmaFormaDePagamento(id,
        contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/formas_pagamento/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'AlterarUmaFormaDePagamento412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * > #### Atenção
     * > O endpoint de pedidos acessado pela url `/v1/pedidos` está depreciado. Novas
     * homologações devem ser realizadas na versão 2 (`/v2/pedidos`). A versão 1 não receberá
     * mais atualizações e com o tempo deixará de ser suportada.
     * A entidade Pedidos engloba tanto pedidos realizados quanto orçamentos pendentes.
     * O que diferencia um orçamento de um pedido efetivado é a propriedade status, que pode ser
     * consultado
     * usando GET EX: *https://app.mercos.com/api/v1/pedidos/?alterado_apos=2019-03-01%2007:21:
     * 44&status=2*
     * #### Estrutura de Retorno do Pedido
     * | Campo                      | Tipo        | Descrição
     * |
     * |----------------------------|-------------|-----------------------------------------------
     * -----------------------------------------------------------------------|
     * | id                         | Integer     | Identificador único.
     * |
     * | cliente_id                 | Integer     | Identificador único do cliente.
     * |
     * | cliente_razao_social       | String: 100 | Razão social do cliente
     * |
     * | cliente_nome_fantasia      | String: 100 | Nome fantasia do cliente
     * |
     * | cliente_cnpj               | String: 14  | CNPJ do cliente
     * |
     * | cliente_inscricao_estadual | String: 30  | Inscrição estadual do cliente
     * |
     * | cliente_rua                | String: 100 | Rua do cliente
     * |
     * | cliente_numero             | String: 100 | Número do endereço do cliente
     * |
     * | cliente_complemento        | String: 50  | Complemento do cliente
     * |
     * | cliente_cep                | String: 8   | CEP do cliente
     * |
     * | cliente_bairro             | String: 30  | Bairro do cliente
     * |
     * | cliente_cidade             | String: 50  | Cidade do cliente
     * |
     * | cliente_estado             | String: 2   | Estado do cliente
     * |
     * | cliente_suframa            | String: 20  | Suframa do cliente
     * |
     * | representada_id            | Integer     | ID da Representada
     * |
     * | representada_nome_fantasia | String: 50  | Nome fantasia da Representada
     * |
     * | representada_razao_social  | String: 50  | Razão Social da Representada
     * |
     * | transportadora_id          | Integer     | Identificador único da transportadora.
     * |
     * | criador_id                 | Integer     | Identificador único do vendedor que fez o
     * pedido.                                                                    |
     * | nome_contato               | String: 50  | Nome do contato do cliente.
     * |
     * | status                     | String: 1   | Status atual do pedido. 0 = Cancelado, 1 =
     * Orçamento, 2 = Pedido.                                                    |
     * | numero                     | Integer     | Número auto-incremental do pedido.
     * |
     * | total                      | Double      | Valor total do pedido.
     * |
     * | condicao_pagamento         | String: 100 | Condição de pagamento em formato texto livre.
     * É usado apenas caso você não integre a entidade Condições de Pagamento. |
     * | condicao_pagamento_id      | Integer     | Identificador único da condição de pagamento.
     * É usado apenas caso você integre a entidade Condições de Pagamento.     |
     * | tipo_pedido_id             | Integer     | Identificador único do tipo de pedido.É usado
     * apenas caso você integre a entidade Tipo de Pedido.                    |
     * | forma_pagamento_id         | Integer     | Identificador único da forma de pagamento.É
     * usado apenas caso você integre a entidade Formas de Pagamento.           |
     * | data_emissao               | Date        | Data de emissão do pedido. Pode ser null.
     * |
     * | observacoes                | String: 500 | Informações adicionais que o vendedor
     * registrou no pedido.
     * | status_custom_id           | Integer     | Identificador único do status de pedido
     * customizado. É usado apenas caso você integre a entidade Status de Pedido Customizado.|
     * | status_b2b                 | Integer     | Status atual do pedido no B2b. null = Pedido
     * não foi gerado com o B2B, 1 = Em aberto, 2 = Concluído.                 |
     * #### Estrutura de Retorno do Item do pedido
     * | Campo                   | Tipo        | Descrição
     * 
     * 
     * |
     * |-------------------------|-------------|--------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * -------------------------------------------|
     * | id                      | Integer     | Identificador único do item do pedido.
     * 
     * 
     * |
     * | produto_id              | Integer     | ID do produto na Mercos.
     * 
     * 
     * |
     * | produto_codigo          | String: 50  | Código do Produto na Mercos.
     * 
     * 
     * |
     * | produto_nome            | String: 100 | Nome do Produto na Mercos.
     * 
     * 
     * |
     * | tabela_preco_id         | Integer     | ID da tabela de preço na Mercos. Caso tenha sido
     * utilizado o preço padrão (campo “preco_tabela” da entidade Produto), a tabela_preco_id
     * será null.
     * |
     * | quantidade              | Double      | Quantidade vendida.
     * 
     * 
     * |
     * | preco_bruto             | Double      | Preço padrão do produto no momento da venda
     * (campo “preco_tabela” da entidade Produto) ou caso tenha sido utilizada uma tabela de
     * preço (tabela_preco_id diferente de null) será o valor da tabela de preço utilizada.
     * |
     * | preco_liquido           | Double      | Preço de venda do produto.
     * 
     * 
     * |
     * | cotacao_moeda           | Double      | Cotação da moeda, em caso de venda em moeda
     * estrangeira.
     * 
     * |
     * | quantidade_grades       | List        | Lista com as grades de cores e tamanhos usadas,
     * e suas respectivas quantidades. Caso o produto possua somente Cor, o Tamanho será null, e
     * vice-versa. A soma das quantidades nesta lista será igual ao campo quantidade do item.cor
     * String: 15tamanho String: 15quantidade Double |
     * | descontos_do_vendedor   | List        | Lista com os descontos concedidos pelo vendedor
     * ao item, em formato Double.
     * 
     * |
     * | descontos_de_promocoes  | List        | Lista com os descontos de promoções aplicadas ao
     * item, cada elemento da lista é um objeto no formato: ```{"regra_id": Integer, "desconto":
     * Double}```
     * |
     * | descontos_de_politicas  | List        | Lista com os acréscimos ou descontos de
     * políticas comerciais aplicadas ao item, cada elemento da lista é um objeto no formato:
     * ```{"regra_id": Integer, "desconto": Double} ``` *Um acréscimo é identificado por um
     * desconto com valor negativo.*                                                  |
     * | descontos               | List        | Lista com todos os descontos aplicados ao item,
     * em formato Double. O valor deste campo é igual a concatenação dos valores dos campos
     * `descontos_do_vendedor`, `descontos_de_promocoes` e `descontos_de_politicas`.
     * |
     * | observacoes             | String: 500 | Informações adicionais que o vendedor registrou
     * no item.
     * 
     * |
     * | excluido                | Boolean     | Indica se o item está excluído.
     * 
     * 
     * |
     * | ipi                     | Double      | Valor do IPI do produto
     * 
     * 
     * |
     * | tipo_ipi                | Char        | Indica se o IPI é percentual P ou valor fixo V
     * 
     * 
     * |
     * | st                      | Double      | Valor da ST (Substituição Tributária)
     * 
     * 
     * |
     * | subtotal                | Double      | Subtotal final calculado
     * 
     * 
     * |
     * #### Estrutura de Retorno de Campos extras do pedido
     * | Campo          | Tipo       | Descrição                           |
     * |----------------|------------|-------------------------------------|
     * | campo_extra_id | Integer    | Identificador único do campo extra. |
     * | nome           | String: 50 | Nome do campo extra.                |
     * | tipo | String| (“0”) Texto livre, (“1”) data, ("2") numérico, ("3") hora, ("4") Lista e
     * ("5") Somente leitura. |
     * | valor_texto    | String: 50 | Retorna um texto se o campo for do tipo texto ou somente
     * leitura. |
     * | valor_data     | String | Retorna uma data se o campo for do tipo data. |
     * | valor_decimal  | Double | Retorna um Double se o campo for do tipo numérico. |
     * | valor_hora     | String | Retorna uma hora o valor se o campo for do tipo texto. |
     * | valor_lista    | List  | Retorna uma lista de Ids e valores dos itens da lista, ex: [[1,
     * "sp"], [2, "sc"]]. |
     * | valor          | | O tipo deste atributo depente do tipo do campo extra como descrito na
     * tabela abaixo. |
     * | Tipo do campo extra | Tipo      | Formato|
     * | --------------------| ----------|--------|
     * | Texto simples("0") | String: 50| |
     * | Data("1") | String | "yyyy-dd-mm", ex: "2018-21-02". |
     * | Numérico("2") | Double | Valor máximo: 99999999.99999. |
     * | Hora("3") | String | "HH:mm",  ex: "21:56".|
     * | Lista("4") | List | Retorna uma lista de Ids e valores dos itens da lista, ex: [[1,
     * "sp"], [2, "sc"]]. |
     * | Somente leitura("5") | String: 50| |
     * #### Estrutura de Envio de Campos extras do pedido
     * Obs: os campos extras cadastrados que não forem enviados serão salvo como vazio.
     * | Campo          | Tipo       | Descrição                           |
     * |----------------|------------|-------------------------------------|
     * | id             | Integer    | Identificador único do campo extra. |
     * | valor          | | O tipo deste atributo depente do tipo do campo extra como descrito na
     * tabela abaixo.|
     * | Tipo do campo extra | Tipo      | Formato|
     * | --------------------| ----------|--------|
     * | Texto simples("0") | String: 50| |
     * | Data("1") | String | "yyyy-dd-mm", ex: "2018-21-02" |
     * | Numérico("2") | Double | Valor máximo: 99999999.99999 |
     * | Hora("3") | String | "HH:mm",  ex: "21:56"|
     * | Lista("4") | List: int | Lista de ids dos itens selecionados, se atributo lista_multipla
     * for verdadeiro pode ser enviado mais de 1 id na lista. |
     * | Somente leitura("5") | String: 50| |
     * #### Estrutura de Retorno do Endereço de entrega
     * | Campo       | Tipo        | Descrição
     * |
     * |-------------|-------------|--------------------------------------------------------------
     * -----------------------------------|
     * | id          | Integer     | Identificador único do endereço. Este identificador é o
     * mesmo de endereço adicional de cliente. |
     * | cep         | String: 8   | CEP da localização do endereço
     * |
     * | endereco    | String: 200 | Endereço ou rua
     * |
     * | numero      | String: 100 | Número do local
     * |
     * | complemento | String: 200 | Complementos do endereço
     * |
     * | bairro      | String: 200 | Bairro do endereço
     * |
     * | cidade      | String: 200 | Cidade do endereço
     * |
     * | estado      | String: 2   | Estado da cidade
     * |
     *
     * @param {dateTime} alteradoApos Retorna os registros que foram alterados após esta data.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterTodosOsPedidos(alteradoApos,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/pedidos';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            alterado_apos: _apiHelper.stringifyDateTime(alteradoApos, 'date'),
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * > #### Atenção
     * > O endpoint de pedidos acessado pela url `/v1/pedidos` está depreciado. Novas
     * homologações devem ser realizadas na versão 2 (`/v2/pedidos`). A versão 1 não receberá
     * mais atualizações e com o tempo deixará de ser suportada.
     * A entidade Pedidos engloba tanto pedidos realizados quanto orçamentos pendentes.
     * O que diferencia um orçamento de um pedido efetivado é a propriedade status, que pode ser
     * consultado
     * usando GET EX: *https://app.mercos.com/api/v1/pedidos/?alterado_apos=2019-03-01%2007:21:
     * 44&status=2*
     * #### Estrutura de Retorno do Pedido
     * | Campo                      | Tipo        | Descrição
     * |
     * |----------------------------|-------------|-----------------------------------------------
     * -----------------------------------------------------------------------|
     * | id                         | Integer     | Identificador único.
     * |
     * | cliente_id                 | Integer     | Identificador único do cliente.
     * |
     * | cliente_razao_social       | String: 100 | Razão social do cliente
     * |
     * | cliente_nome_fantasia      | String: 100 | Nome fantasia do cliente
     * |
     * | cliente_cnpj               | String: 14  | CNPJ do cliente
     * |
     * | cliente_inscricao_estadual | String: 30  | Inscrição estadual do cliente
     * |
     * | cliente_rua                | String: 100 | Rua do cliente
     * |
     * | cliente_numero             | String: 100 | Número do endereço do cliente
     * |
     * | cliente_complemento        | String: 50  | Complemento do cliente
     * |
     * | cliente_cep                | String: 8   | CEP do cliente
     * |
     * | cliente_bairro             | String: 30  | Bairro do cliente
     * |
     * | cliente_cidade             | String: 50  | Cidade do cliente
     * |
     * | cliente_estado             | String: 2   | Estado do cliente
     * |
     * | cliente_suframa            | String: 20  | Suframa do cliente
     * |
     * | representada_id            | Integer     | ID da Representada
     * |
     * | representada_nome_fantasia | String: 50  | Nome fantasia da Representada
     * |
     * | representada_razao_social  | String: 50  | Razão Social da Representada
     * |
     * | transportadora_id          | Integer     | Identificador único da transportadora.
     * |
     * | criador_id                 | Integer     | Identificador único do vendedor que fez o
     * pedido.                                                                    |
     * | nome_contato               | String: 50  | Nome do contato do cliente.
     * |
     * | status                     | String: 1   | Status atual do pedido. 0 = Cancelado, 1 =
     * Orçamento, 2 = Pedido.                                                    |
     * | numero                     | Integer     | Número auto-incremental do pedido.
     * |
     * | total                      | Double      | Valor total do pedido.
     * |
     * | condicao_pagamento         | String: 100 | Condição de pagamento em formato texto livre.
     * É usado apenas caso você não integre a entidade Condições de Pagamento. |
     * | condicao_pagamento_id      | Integer     | Identificador único da condição de pagamento.
     * É usado apenas caso você integre a entidade Condições de Pagamento.     |
     * | tipo_pedido_id             | Integer     | Identificador único do tipo de pedido.É usado
     * apenas caso você integre a entidade Tipo de Pedido.                    |
     * | forma_pagamento_id         | Integer     | Identificador único da forma de pagamento.É
     * usado apenas caso você integre a entidade Formas de Pagamento.           |
     * | data_emissao               | Date        | Data de emissão do pedido. Pode ser null.
     * |
     * | observacoes                | String: 500 | Informações adicionais que o vendedor
     * registrou no pedido.
     * | status_custom_id           | Integer     | Identificador único do status de pedido
     * customizado. É usado apenas caso você integre a entidade Status de Pedido Customizado.|
     * | status_b2b                 | Integer     | Status atual do pedido no B2b. null = Pedido
     * não foi gerado com o B2B, 1 = Em aberto, 2 = Concluído.                 |
     * #### Estrutura de Retorno do Item do pedido
     * | Campo                   | Tipo        | Descrição
     * 
     * 
     * |
     * |-------------------------|-------------|--------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * -------------------------------------------|
     * | id                      | Integer     | Identificador único do item do pedido.
     * 
     * 
     * |
     * | produto_id              | Integer     | ID do produto na Mercos.
     * 
     * 
     * |
     * | produto_codigo          | String: 50  | Código do Produto na Mercos.
     * 
     * 
     * |
     * | produto_nome            | String: 100 | Nome do Produto na Mercos.
     * 
     * 
     * |
     * | tabela_preco_id         | Integer     | ID da tabela de preço na Mercos. Caso tenha sido
     * utilizado o preço padrão (campo “preco_tabela” da entidade Produto), a tabela_preco_id
     * será null.
     * |
     * | quantidade              | Double      | Quantidade vendida.
     * 
     * 
     * |
     * | preco_bruto             | Double      | Preço padrão do produto no momento da venda
     * (campo “preco_tabela” da entidade Produto) ou caso tenha sido utilizada uma tabela de
     * preço (tabela_preco_id diferente de null) será o valor da tabela de preço utilizada.
     * |
     * | preco_liquido           | Double      | Preço de venda do produto.
     * 
     * 
     * |
     * | cotacao_moeda           | Double      | Cotação da moeda, em caso de venda em moeda
     * estrangeira.
     * 
     * |
     * | quantidade_grades       | List        | Lista com as grades de cores e tamanhos usadas,
     * e suas respectivas quantidades. Caso o produto possua somente Cor, o Tamanho será null, e
     * vice-versa. A soma das quantidades nesta lista será igual ao campo quantidade do item.cor
     * String: 15tamanho String: 15quantidade Double |
     * | descontos_do_vendedor   | List        | Lista com os descontos concedidos pelo vendedor
     * ao item, em formato Double.
     * 
     * |
     * | descontos_de_promocoes  | List        | Lista com os descontos de promoções aplicadas ao
     * item, cada elemento da lista é um objeto no formato: ```{"regra_id": Integer, "desconto":
     * Double}```
     * |
     * | descontos_de_politicas  | List        | Lista com os acréscimos ou descontos de
     * políticas comerciais aplicadas ao item, cada elemento da lista é um objeto no formato:
     * ```{"regra_id": Integer, "desconto": Double} ``` *Um acréscimo é identificado por um
     * desconto com valor negativo.*                                                  |
     * | descontos               | List        | Lista com todos os descontos aplicados ao item,
     * em formato Double. O valor deste campo é igual a concatenação dos valores dos campos
     * `descontos_do_vendedor`, `descontos_de_promocoes` e `descontos_de_politicas`.
     * |
     * | observacoes             | String: 500 | Informações adicionais que o vendedor registrou
     * no item.
     * 
     * |
     * | excluido                | Boolean     | Indica se o item está excluído.
     * 
     * 
     * |
     * | ipi                     | Double      | Valor do IPI do produto
     * 
     * 
     * |
     * | tipo_ipi                | Char        | Indica se o IPI é percentual P ou valor fixo V
     * 
     * 
     * |
     * | st                      | Double      | Valor da ST (Substituição Tributária)
     * 
     * 
     * |
     * | subtotal                | Double      | Subtotal final calculado
     * 
     * 
     * |
     * #### Estrutura de Retorno de Campos extras do pedido
     * | Campo          | Tipo       | Descrição                           |
     * |----------------|------------|-------------------------------------|
     * | campo_extra_id | Integer    | Identificador único do campo extra. |
     * | nome           | String: 50 | Nome do campo extra.                |
     * | tipo | String| (“0”) Texto livre, (“1”) data, ("2") numérico, ("3") hora, ("4") Lista e
     * ("5") Somente leitura. |
     * | valor_texto    | String: 50 | Retorna um texto se o campo for do tipo texto ou somente
     * leitura. |
     * | valor_data     | String | Retorna uma data se o campo for do tipo data. |
     * | valor_decimal  | Double | Retorna um Double se o campo for do tipo numérico. |
     * | valor_hora     | String | Retorna uma hora o valor se o campo for do tipo texto. |
     * | valor_lista    | List  | Retorna uma lista de Ids e valores dos itens da lista, ex: [[1,
     * "sp"], [2, "sc"]]. |
     * | valor          | | O tipo deste atributo depente do tipo do campo extra como descrito na
     * tabela abaixo. |
     * | Tipo do campo extra | Tipo      | Formato|
     * | --------------------| ----------|--------|
     * | Texto simples("0") | String: 50| |
     * | Data("1") | String | "yyyy-dd-mm", ex: "2018-21-02". |
     * | Numérico("2") | Double | Valor máximo: 99999999.99999. |
     * | Hora("3") | String | "HH:mm",  ex: "21:56".|
     * | Lista("4") | List | Retorna uma lista de Ids e valores dos itens da lista, ex: [[1,
     * "sp"], [2, "sc"]]. |
     * | Somente leitura("5") | String: 50| |
     * #### Estrutura de Envio de Campos extras do pedido
     * Obs: os campos extras cadastrados que não forem enviados serão salvo como vazio.
     * | Campo          | Tipo       | Descrição                           |
     * |----------------|------------|-------------------------------------|
     * | id             | Integer    | Identificador único do campo extra. |
     * | valor          | | O tipo deste atributo depente do tipo do campo extra como descrito na
     * tabela abaixo.|
     * | Tipo do campo extra | Tipo      | Formato|
     * | --------------------| ----------|--------|
     * | Texto simples("0") | String: 50| |
     * | Data("1") | String | "yyyy-dd-mm", ex: "2018-21-02" |
     * | Numérico("2") | Double | Valor máximo: 99999999.99999 |
     * | Hora("3") | String | "HH:mm",  ex: "21:56"|
     * | Lista("4") | List: int | Lista de ids dos itens selecionados, se atributo lista_multipla
     * for verdadeiro pode ser enviado mais de 1 id na lista. |
     * | Somente leitura("5") | String: 50| |
     * #### Estrutura de Retorno do Endereço de entrega
     * | Campo       | Tipo        | Descrição
     * |
     * |-------------|-------------|--------------------------------------------------------------
     * -----------------------------------|
     * | id          | Integer     | Identificador único do endereço. Este identificador é o
     * mesmo de endereço adicional de cliente. |
     * | cep         | String: 8   | CEP da localização do endereço
     * |
     * | endereco    | String: 200 | Endereço ou rua
     * |
     * | numero      | String: 100 | Número do local
     * |
     * | complemento | String: 200 | Complementos do endereço
     * |
     * | bairro      | String: 200 | Bairro do endereço
     * |
     * | cidade      | String: 200 | Cidade do endereço
     * |
     * | estado      | String: 2   | Estado da cidade
     * |
     *
     * @param {double} id ID do Pedido no sistema Mercos.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterUmPedidoEspecFico(id, contentType, applicationToken, companyToken, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/pedidos/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * > #### Atenção
     * > O endpoint de pedidos acessado pela url `/v1/pedidos` está depreciado. Novas
     * homologações devem ser realizadas na versão 2 (`/v2/pedidos`). A versão 1 não receberá
     * mais atualizações e com o tempo deixará de ser suportada.
     * A entidade Pedidos engloba tanto pedidos realizados quanto orçamentos pendentes.
     * O que diferencia um orçamento de um pedido efetivado é a propriedade status, que pode ser
     * consultado
     * usando GET EX: *https://app.mercos.com/api/v1/pedidos/?alterado_apos=2019-03-01%2007:21:
     * 44&status=2*
     * #### Estrutura de Retorno do Pedido
     * | Campo                      | Tipo        | Descrição
     * |
     * |----------------------------|-------------|-----------------------------------------------
     * -----------------------------------------------------------------------|
     * | id                         | Integer     | Identificador único.
     * |
     * | cliente_id                 | Integer     | Identificador único do cliente.
     * |
     * | cliente_razao_social       | String: 100 | Razão social do cliente
     * |
     * | cliente_nome_fantasia      | String: 100 | Nome fantasia do cliente
     * |
     * | cliente_cnpj               | String: 14  | CNPJ do cliente
     * |
     * | cliente_inscricao_estadual | String: 30  | Inscrição estadual do cliente
     * |
     * | cliente_rua                | String: 100 | Rua do cliente
     * |
     * | cliente_numero             | String: 100 | Número do endereço do cliente
     * |
     * | cliente_complemento        | String: 50  | Complemento do cliente
     * |
     * | cliente_cep                | String: 8   | CEP do cliente
     * |
     * | cliente_bairro             | String: 30  | Bairro do cliente
     * |
     * | cliente_cidade             | String: 50  | Cidade do cliente
     * |
     * | cliente_estado             | String: 2   | Estado do cliente
     * |
     * | cliente_suframa            | String: 20  | Suframa do cliente
     * |
     * | representada_id            | Integer     | ID da Representada
     * |
     * | representada_nome_fantasia | String: 50  | Nome fantasia da Representada
     * |
     * | representada_razao_social  | String: 50  | Razão Social da Representada
     * |
     * | transportadora_id          | Integer     | Identificador único da transportadora.
     * |
     * | criador_id                 | Integer     | Identificador único do vendedor que fez o
     * pedido.                                                                    |
     * | nome_contato               | String: 50  | Nome do contato do cliente.
     * |
     * | status                     | String: 1   | Status atual do pedido. 0 = Cancelado, 1 =
     * Orçamento, 2 = Pedido.                                                    |
     * | numero                     | Integer     | Número auto-incremental do pedido.
     * |
     * | total                      | Double      | Valor total do pedido.
     * |
     * | condicao_pagamento         | String: 100 | Condição de pagamento em formato texto livre.
     * É usado apenas caso você não integre a entidade Condições de Pagamento. |
     * | condicao_pagamento_id      | Integer     | Identificador único da condição de pagamento.
     * É usado apenas caso você integre a entidade Condições de Pagamento.     |
     * | tipo_pedido_id             | Integer     | Identificador único do tipo de pedido.É usado
     * apenas caso você integre a entidade Tipo de Pedido.                    |
     * | forma_pagamento_id         | Integer     | Identificador único da forma de pagamento.É
     * usado apenas caso você integre a entidade Formas de Pagamento.           |
     * | data_emissao               | Date        | Data de emissão do pedido. Pode ser null.
     * |
     * | observacoes                | String: 500 | Informações adicionais que o vendedor
     * registrou no pedido.
     * | status_custom_id           | Integer     | Identificador único do status de pedido
     * customizado. É usado apenas caso você integre a entidade Status de Pedido Customizado.|
     * | status_b2b                 | Integer     | Status atual do pedido no B2b. null = Pedido
     * não foi gerado com o B2B, 1 = Em aberto, 2 = Concluído.                 |
     * #### Estrutura de Retorno do Item do pedido
     * | Campo                   | Tipo        | Descrição
     * 
     * 
     * |
     * |-------------------------|-------------|--------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * -------------------------------------------|
     * | id                      | Integer     | Identificador único do item do pedido.
     * 
     * 
     * |
     * | produto_id              | Integer     | ID do produto na Mercos.
     * 
     * 
     * |
     * | produto_codigo          | String: 50  | Código do Produto na Mercos.
     * 
     * 
     * |
     * | produto_nome            | String: 100 | Nome do Produto na Mercos.
     * 
     * 
     * |
     * | tabela_preco_id         | Integer     | ID da tabela de preço na Mercos. Caso tenha sido
     * utilizado o preço padrão (campo “preco_tabela” da entidade Produto), a tabela_preco_id
     * será null.
     * |
     * | quantidade              | Double      | Quantidade vendida.
     * 
     * 
     * |
     * | preco_bruto             | Double      | Preço padrão do produto no momento da venda
     * (campo “preco_tabela” da entidade Produto) ou caso tenha sido utilizada uma tabela de
     * preço (tabela_preco_id diferente de null) será o valor da tabela de preço utilizada.
     * |
     * | preco_liquido           | Double      | Preço de venda do produto.
     * 
     * 
     * |
     * | cotacao_moeda           | Double      | Cotação da moeda, em caso de venda em moeda
     * estrangeira.
     * 
     * |
     * | quantidade_grades       | List        | Lista com as grades de cores e tamanhos usadas,
     * e suas respectivas quantidades. Caso o produto possua somente Cor, o Tamanho será null, e
     * vice-versa. A soma das quantidades nesta lista será igual ao campo quantidade do item.cor
     * String: 15tamanho String: 15quantidade Double |
     * | descontos_do_vendedor   | List        | Lista com os descontos concedidos pelo vendedor
     * ao item, em formato Double.
     * 
     * |
     * | descontos_de_promocoes  | List        | Lista com os descontos de promoções aplicadas ao
     * item, cada elemento da lista é um objeto no formato: ```{"regra_id": Integer, "desconto":
     * Double}```
     * |
     * | descontos_de_politicas  | List        | Lista com os acréscimos ou descontos de
     * políticas comerciais aplicadas ao item, cada elemento da lista é um objeto no formato:
     * ```{"regra_id": Integer, "desconto": Double} ``` *Um acréscimo é identificado por um
     * desconto com valor negativo.*                                                  |
     * | descontos               | List        | Lista com todos os descontos aplicados ao item,
     * em formato Double. O valor deste campo é igual a concatenação dos valores dos campos
     * `descontos_do_vendedor`, `descontos_de_promocoes` e `descontos_de_politicas`.
     * |
     * | observacoes             | String: 500 | Informações adicionais que o vendedor registrou
     * no item.
     * 
     * |
     * | excluido                | Boolean     | Indica se o item está excluído.
     * 
     * 
     * |
     * | ipi                     | Double      | Valor do IPI do produto
     * 
     * 
     * |
     * | tipo_ipi                | Char        | Indica se o IPI é percentual P ou valor fixo V
     * 
     * 
     * |
     * | st                      | Double      | Valor da ST (Substituição Tributária)
     * 
     * 
     * |
     * | subtotal                | Double      | Subtotal final calculado
     * 
     * 
     * |
     * #### Estrutura de Retorno de Campos extras do pedido
     * | Campo          | Tipo       | Descrição                           |
     * |----------------|------------|-------------------------------------|
     * | campo_extra_id | Integer    | Identificador único do campo extra. |
     * | nome           | String: 50 | Nome do campo extra.                |
     * | tipo | String| (“0”) Texto livre, (“1”) data, ("2") numérico, ("3") hora, ("4") Lista e
     * ("5") Somente leitura. |
     * | valor_texto    | String: 50 | Retorna um texto se o campo for do tipo texto ou somente
     * leitura. |
     * | valor_data     | String | Retorna uma data se o campo for do tipo data. |
     * | valor_decimal  | Double | Retorna um Double se o campo for do tipo numérico. |
     * | valor_hora     | String | Retorna uma hora o valor se o campo for do tipo texto. |
     * | valor_lista    | List  | Retorna uma lista de Ids e valores dos itens da lista, ex: [[1,
     * "sp"], [2, "sc"]]. |
     * | valor          | | O tipo deste atributo depente do tipo do campo extra como descrito na
     * tabela abaixo. |
     * | Tipo do campo extra | Tipo      | Formato|
     * | --------------------| ----------|--------|
     * | Texto simples("0") | String: 50| |
     * | Data("1") | String | "yyyy-dd-mm", ex: "2018-21-02". |
     * | Numérico("2") | Double | Valor máximo: 99999999.99999. |
     * | Hora("3") | String | "HH:mm",  ex: "21:56".|
     * | Lista("4") | List | Retorna uma lista de Ids e valores dos itens da lista, ex: [[1,
     * "sp"], [2, "sc"]]. |
     * | Somente leitura("5") | String: 50| |
     * #### Estrutura de Envio de Campos extras do pedido
     * Obs: os campos extras cadastrados que não forem enviados serão salvo como vazio.
     * | Campo          | Tipo       | Descrição                           |
     * |----------------|------------|-------------------------------------|
     * | id             | Integer    | Identificador único do campo extra. |
     * | valor          | | O tipo deste atributo depente do tipo do campo extra como descrito na
     * tabela abaixo.|
     * | Tipo do campo extra | Tipo      | Formato|
     * | --------------------| ----------|--------|
     * | Texto simples("0") | String: 50| |
     * | Data("1") | String | "yyyy-dd-mm", ex: "2018-21-02" |
     * | Numérico("2") | Double | Valor máximo: 99999999.99999 |
     * | Hora("3") | String | "HH:mm",  ex: "21:56"|
     * | Lista("4") | List: int | Lista de ids dos itens selecionados, se atributo lista_multipla
     * for verdadeiro pode ser enviado mais de 1 id na lista. |
     * | Somente leitura("5") | String: 50| |
     * #### Estrutura de Retorno do Endereço de entrega
     * | Campo       | Tipo        | Descrição
     * |
     * |-------------|-------------|--------------------------------------------------------------
     * -----------------------------------|
     * | id          | Integer     | Identificador único do endereço. Este identificador é o
     * mesmo de endereço adicional de cliente. |
     * | cep         | String: 8   | CEP da localização do endereço
     * |
     * | endereco    | String: 200 | Endereço ou rua
     * |
     * | numero      | String: 100 | Número do local
     * |
     * | complemento | String: 200 | Complementos do endereço
     * |
     * | bairro      | String: 200 | Bairro do endereço
     * |
     * | cidade      | String: 200 | Cidade do endereço
     * |
     * | estado      | String: 2   | Estado da cidade
     * |
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {IncluirUmPedidoRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createIncluirUmPedido(contentType, applicationToken, companyToken, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/pedidos';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'IncluirUmPedidoResponse');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'IncluirUmPedido412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * > #### Atenção
     * > O endpoint de pedidos acessado pela url `/v1/pedidos` está depreciado. Novas
     * homologações devem ser realizadas na versão 2 (`/v2/pedidos`). A versão 1 não receberá
     * mais atualizações e com o tempo deixará de ser suportada.
     * A entidade Pedidos engloba tanto pedidos realizados quanto orçamentos pendentes.
     * O que diferencia um orçamento de um pedido efetivado é a propriedade status, que pode ser
     * consultado
     * usando GET EX: *https://app.mercos.com/api/v1/pedidos/?alterado_apos=2019-03-01%2007:21:
     * 44&status=2*
     * #### Estrutura de Retorno do Pedido
     * | Campo                      | Tipo        | Descrição
     * |
     * |----------------------------|-------------|-----------------------------------------------
     * -----------------------------------------------------------------------|
     * | id                         | Integer     | Identificador único.
     * |
     * | cliente_id                 | Integer     | Identificador único do cliente.
     * |
     * | cliente_razao_social       | String: 100 | Razão social do cliente
     * |
     * | cliente_nome_fantasia      | String: 100 | Nome fantasia do cliente
     * |
     * | cliente_cnpj               | String: 14  | CNPJ do cliente
     * |
     * | cliente_inscricao_estadual | String: 30  | Inscrição estadual do cliente
     * |
     * | cliente_rua                | String: 100 | Rua do cliente
     * |
     * | cliente_numero             | String: 100 | Número do endereço do cliente
     * |
     * | cliente_complemento        | String: 50  | Complemento do cliente
     * |
     * | cliente_cep                | String: 8   | CEP do cliente
     * |
     * | cliente_bairro             | String: 30  | Bairro do cliente
     * |
     * | cliente_cidade             | String: 50  | Cidade do cliente
     * |
     * | cliente_estado             | String: 2   | Estado do cliente
     * |
     * | cliente_suframa            | String: 20  | Suframa do cliente
     * |
     * | representada_id            | Integer     | ID da Representada
     * |
     * | representada_nome_fantasia | String: 50  | Nome fantasia da Representada
     * |
     * | representada_razao_social  | String: 50  | Razão Social da Representada
     * |
     * | transportadora_id          | Integer     | Identificador único da transportadora.
     * |
     * | criador_id                 | Integer     | Identificador único do vendedor que fez o
     * pedido.                                                                    |
     * | nome_contato               | String: 50  | Nome do contato do cliente.
     * |
     * | status                     | String: 1   | Status atual do pedido. 0 = Cancelado, 1 =
     * Orçamento, 2 = Pedido.                                                    |
     * | numero                     | Integer     | Número auto-incremental do pedido.
     * |
     * | total                      | Double      | Valor total do pedido.
     * |
     * | condicao_pagamento         | String: 100 | Condição de pagamento em formato texto livre.
     * É usado apenas caso você não integre a entidade Condições de Pagamento. |
     * | condicao_pagamento_id      | Integer     | Identificador único da condição de pagamento.
     * É usado apenas caso você integre a entidade Condições de Pagamento.     |
     * | tipo_pedido_id             | Integer     | Identificador único do tipo de pedido.É usado
     * apenas caso você integre a entidade Tipo de Pedido.                    |
     * | forma_pagamento_id         | Integer     | Identificador único da forma de pagamento.É
     * usado apenas caso você integre a entidade Formas de Pagamento.           |
     * | data_emissao               | Date        | Data de emissão do pedido. Pode ser null.
     * |
     * | observacoes                | String: 500 | Informações adicionais que o vendedor
     * registrou no pedido.
     * | status_custom_id           | Integer     | Identificador único do status de pedido
     * customizado. É usado apenas caso você integre a entidade Status de Pedido Customizado.|
     * | status_b2b                 | Integer     | Status atual do pedido no B2b. null = Pedido
     * não foi gerado com o B2B, 1 = Em aberto, 2 = Concluído.                 |
     * #### Estrutura de Retorno do Item do pedido
     * | Campo                   | Tipo        | Descrição
     * 
     * 
     * |
     * |-------------------------|-------------|--------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * -------------------------------------------|
     * | id                      | Integer     | Identificador único do item do pedido.
     * 
     * 
     * |
     * | produto_id              | Integer     | ID do produto na Mercos.
     * 
     * 
     * |
     * | produto_codigo          | String: 50  | Código do Produto na Mercos.
     * 
     * 
     * |
     * | produto_nome            | String: 100 | Nome do Produto na Mercos.
     * 
     * 
     * |
     * | tabela_preco_id         | Integer     | ID da tabela de preço na Mercos. Caso tenha sido
     * utilizado o preço padrão (campo “preco_tabela” da entidade Produto), a tabela_preco_id
     * será null.
     * |
     * | quantidade              | Double      | Quantidade vendida.
     * 
     * 
     * |
     * | preco_bruto             | Double      | Preço padrão do produto no momento da venda
     * (campo “preco_tabela” da entidade Produto) ou caso tenha sido utilizada uma tabela de
     * preço (tabela_preco_id diferente de null) será o valor da tabela de preço utilizada.
     * |
     * | preco_liquido           | Double      | Preço de venda do produto.
     * 
     * 
     * |
     * | cotacao_moeda           | Double      | Cotação da moeda, em caso de venda em moeda
     * estrangeira.
     * 
     * |
     * | quantidade_grades       | List        | Lista com as grades de cores e tamanhos usadas,
     * e suas respectivas quantidades. Caso o produto possua somente Cor, o Tamanho será null, e
     * vice-versa. A soma das quantidades nesta lista será igual ao campo quantidade do item.cor
     * String: 15tamanho String: 15quantidade Double |
     * | descontos_do_vendedor   | List        | Lista com os descontos concedidos pelo vendedor
     * ao item, em formato Double.
     * 
     * |
     * | descontos_de_promocoes  | List        | Lista com os descontos de promoções aplicadas ao
     * item, cada elemento da lista é um objeto no formato: ```{"regra_id": Integer, "desconto":
     * Double}```
     * |
     * | descontos_de_politicas  | List        | Lista com os acréscimos ou descontos de
     * políticas comerciais aplicadas ao item, cada elemento da lista é um objeto no formato:
     * ```{"regra_id": Integer, "desconto": Double} ``` *Um acréscimo é identificado por um
     * desconto com valor negativo.*                                                  |
     * | descontos               | List        | Lista com todos os descontos aplicados ao item,
     * em formato Double. O valor deste campo é igual a concatenação dos valores dos campos
     * `descontos_do_vendedor`, `descontos_de_promocoes` e `descontos_de_politicas`.
     * |
     * | observacoes             | String: 500 | Informações adicionais que o vendedor registrou
     * no item.
     * 
     * |
     * | excluido                | Boolean     | Indica se o item está excluído.
     * 
     * 
     * |
     * | ipi                     | Double      | Valor do IPI do produto
     * 
     * 
     * |
     * | tipo_ipi                | Char        | Indica se o IPI é percentual P ou valor fixo V
     * 
     * 
     * |
     * | st                      | Double      | Valor da ST (Substituição Tributária)
     * 
     * 
     * |
     * | subtotal                | Double      | Subtotal final calculado
     * 
     * 
     * |
     * #### Estrutura de Retorno de Campos extras do pedido
     * | Campo          | Tipo       | Descrição                           |
     * |----------------|------------|-------------------------------------|
     * | campo_extra_id | Integer    | Identificador único do campo extra. |
     * | nome           | String: 50 | Nome do campo extra.                |
     * | tipo | String| (“0”) Texto livre, (“1”) data, ("2") numérico, ("3") hora, ("4") Lista e
     * ("5") Somente leitura. |
     * | valor_texto    | String: 50 | Retorna um texto se o campo for do tipo texto ou somente
     * leitura. |
     * | valor_data     | String | Retorna uma data se o campo for do tipo data. |
     * | valor_decimal  | Double | Retorna um Double se o campo for do tipo numérico. |
     * | valor_hora     | String | Retorna uma hora o valor se o campo for do tipo texto. |
     * | valor_lista    | List  | Retorna uma lista de Ids e valores dos itens da lista, ex: [[1,
     * "sp"], [2, "sc"]]. |
     * | valor          | | O tipo deste atributo depente do tipo do campo extra como descrito na
     * tabela abaixo. |
     * | Tipo do campo extra | Tipo      | Formato|
     * | --------------------| ----------|--------|
     * | Texto simples("0") | String: 50| |
     * | Data("1") | String | "yyyy-dd-mm", ex: "2018-21-02". |
     * | Numérico("2") | Double | Valor máximo: 99999999.99999. |
     * | Hora("3") | String | "HH:mm",  ex: "21:56".|
     * | Lista("4") | List | Retorna uma lista de Ids e valores dos itens da lista, ex: [[1,
     * "sp"], [2, "sc"]]. |
     * | Somente leitura("5") | String: 50| |
     * #### Estrutura de Envio de Campos extras do pedido
     * Obs: os campos extras cadastrados que não forem enviados serão salvo como vazio.
     * | Campo          | Tipo       | Descrição                           |
     * |----------------|------------|-------------------------------------|
     * | id             | Integer    | Identificador único do campo extra. |
     * | valor          | | O tipo deste atributo depente do tipo do campo extra como descrito na
     * tabela abaixo.|
     * | Tipo do campo extra | Tipo      | Formato|
     * | --------------------| ----------|--------|
     * | Texto simples("0") | String: 50| |
     * | Data("1") | String | "yyyy-dd-mm", ex: "2018-21-02" |
     * | Numérico("2") | Double | Valor máximo: 99999999.99999 |
     * | Hora("3") | String | "HH:mm",  ex: "21:56"|
     * | Lista("4") | List: int | Lista de ids dos itens selecionados, se atributo lista_multipla
     * for verdadeiro pode ser enviado mais de 1 id na lista. |
     * | Somente leitura("5") | String: 50| |
     * #### Estrutura de Retorno do Endereço de entrega
     * | Campo       | Tipo        | Descrição
     * |
     * |-------------|-------------|--------------------------------------------------------------
     * -----------------------------------|
     * | id          | Integer     | Identificador único do endereço. Este identificador é o
     * mesmo de endereço adicional de cliente. |
     * | cep         | String: 8   | CEP da localização do endereço
     * |
     * | endereco    | String: 200 | Endereço ou rua
     * |
     * | numero      | String: 100 | Número do local
     * |
     * | complemento | String: 200 | Complementos do endereço
     * |
     * | bairro      | String: 200 | Bairro do endereço
     * |
     * | cidade      | String: 200 | Cidade do endereço
     * |
     * | estado      | String: 2   | Estado da cidade
     * |
     *
     * @param {double} id ID do Pedido no sistema Mercos.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {AlterarUmPedidoRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static alterarUmPedido(id, contentType, applicationToken, companyToken, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/pedidos/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'AlterarUmPedido412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade Pedidos engloba tanto pedidos realizados quanto orçamentos pendentes.
     * O que diferencia um orçamento de um pedido efetivado é a propriedade status, que pode ser
     * consultado
     * usando GET EX: *https://app.mercos.com/api/v2/pedidos/?alterado_apos=2019-03-01%2007:21:
     * 44&status=2*
     * ### O que mudou da v1 para a v2
     * **GET:**
     * - O campo "items" foi renomeado para "itens".
     * - O campo "descontos" foi removido.
     * - O campo "preco_bruto" foi renomeado para "preco_tabela".
     * - Nos campos "descontos_de_promocoes" e "descontos_de_politicas" é retornada uma lista
     * contendo o ID da regra e o percentual de desconto.
     * **POST:**
     * - O campo "descontos" foi renomeado para "descontos_do_vendedor".
     * - Os campos "descontos_de_promocoes" e "descontos_de_politicas" foram acrescentados.
     * - O campo "preco_bruto" foi renomeado para "preco_tabela".
     * - Os IDs dos itens criados são retornados no corpo da resposta.
     * **PUT:**
     * - O campo "descontos" foi renomeado para "descontos_do_vendedor".
     * - Os campos "descontos_de_promocoes" e "descontos_de_politicas" foram acrescentados.
     * - O campo "preco_bruto" foi renomeado para "preco_tabela".
     * - Os IDs dos itens criados ou atualizados são retornados no corpo da resposta.
     * #### Estrutura de Retorno do Pedido
     * | Campo                      | Tipo        | Descrição
     * |
     * |----------------------------|-------------|-----------------------------------------------
     * -----------------------------------------------------------------------|
     * | id                         | Integer     | Identificador único.
     * |
     * | cliente_id                 | Integer     | Identificador único do cliente.
     * |
     * | cliente_razao_social       | String: 100 | Razão social do cliente
     * |
     * | cliente_nome_fantasia      | String: 100 | Nome fantasia do cliente
     * |
     * | cliente_cnpj               | String: 14  | CNPJ do cliente
     * |
     * | cliente_inscricao_estadual | String: 30  | Inscrição estadual do cliente
     * |
     * | cliente_rua                | String: 100 | Rua do cliente
     * |
     * | cliente_numero             | String: 100 | Número do endereço do cliente
     * |
     * | cliente_complemento        | String: 50  | Complemento do cliente
     * |
     * | cliente_cep                | String: 8   | CEP do cliente
     * |
     * | cliente_bairro             | String: 30  | Bairro do cliente
     * |
     * | cliente_cidade             | String: 50  | Cidade do cliente
     * |
     * | cliente_estado             | String: 2   | Estado do cliente
     * |
     * | cliente_suframa            | String: 20  | Suframa do cliente
     * |
     * | representada_id            | Integer     | ID da Representada
     * |
     * | representada_nome_fantasia | String: 50  | Nome fantasia da Representada
     * |
     * | representada_razao_social  | String: 50  | Razão Social da Representada
     * |
     * | transportadora_id          | Integer     | Identificador único da transportadora.
     * |
     * | criador_id                 | Integer     | Identificador único do vendedor que fez o
     * pedido.                                                                    |
     * | nome_contato               | String: 50  | Nome do contato do cliente.
     * |
     * | status                     | String: 1   | Status atual do pedido. 0 = Cancelado, 1 =
     * Orçamento, 2 = Pedido.                                                    |
     * | numero                     | Integer     | Número auto-incremental do pedido.
     * |
     * | total                      | Double      | Valor total do pedido.
     * |
     * | condicao_pagamento         | String: 100 | Condição de pagamento em formato texto livre.
     * É usado apenas caso você não integre a entidade Condições de Pagamento. |
     * | condicao_pagamento_id      | Integer     | Identificador único da condição de pagamento.
     * É usado apenas caso você integre a entidade Condições de Pagamento.     |
     * | tipo_pedido_id             | Integer     | Identificador único do tipo de pedido.É usado
     * apenas caso você integre a entidade Tipo de Pedido.                    |
     * | forma_pagamento_id         | Integer     | Identificador único da forma de pagamento.É
     * usado apenas caso você integre a entidade Formas de Pagamento.           |
     * | data_emissao               | Date        | Data de emissão do pedido. Pode ser null.
     * |
     * | observacoes                | String: 500 | Informações adicionais que o vendedor
     * registrou no pedido.
     * | status_custom_id           | Integer     | Identificador único do status de pedido
     * customizado. É usado apenas caso você integre a entidade Status de Pedido Customizado.|
     * | status_b2b                 | Integer     | Status atual do pedido no B2b. null = Pedido
     * não foi gerado com o B2B, 1 = Em aberto, 2 = Concluído.                 |
     * #### Estrutura de Retorno do Item do pedido
     * | Campo                   | Tipo        | Descrição
     * 
     * 
     * |
     * |-------------------------|-------------|--------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * -------------------------------------------|
     * | id                      | Integer     | Identificador único do item do pedido.
     * 
     * 
     * |
     * | produto_id              | Integer     | ID do produto na Mercos.
     * 
     * 
     * |
     * | produto_codigo          | String: 50  | Código do Produto na Mercos.
     * 
     * 
     * |
     * | produto_nome            | String: 100 | Nome do Produto na Mercos.
     * 
     * 
     * |
     * | tabela_preco_id         | Integer     | ID da tabela de preço na Mercos. Caso tenha sido
     * utilizado o preço padrão (campo “preco_tabela” da entidade Produto), a tabela_preco_id
     * será null.
     * |
     * | quantidade              | Double      | Quantidade vendida.
     * 
     * 
     * |
     * | preco_tabela            | Double      | Preço padrão do produto no momento da venda
     * (campo “preco_tabela” da entidade Produto) ou caso tenha sido utilizada uma tabela de
     * preço (tabela_preco_id diferente de null) será o valor da tabela de preço utilizada.
     * |
     * | preco_liquido           | Double      | Preço de venda do produto.
     * 
     * 
     * |
     * | cotacao_moeda           | Double      | Cotação da moeda, em caso de venda em moeda
     * estrangeira.
     * 
     * |
     * | quantidade_grades       | List        | Lista com as grades de cores e tamanhos usadas,
     * e suas respectivas quantidades. Caso o produto possua somente Cor, o Tamanho será null, e
     * vice-versa. A soma das quantidades nesta lista será igual ao campo quantidade do item.cor
     * String: 15tamanho String: 15quantidade Double |
     * | descontos_do_vendedor   | List        | Lista com os descontos concedidos pelo vendedor
     * ao item, em formato Double.
     * 
     * |
     * | descontos_de_promocoes  | List        | Lista com os descontos de promoções aplicadas ao
     * item, cada elemento da lista é um objeto no formato: ```{"regra_id": Integer, "desconto":
     * Double}```
     * |
     * | descontos_de_politicas  | List        | Lista com os acréscimos ou descontos de
     * políticas comerciais aplicadas ao item, cada elemento da lista é um objeto no formato:
     * ```{"regra_id": Integer, "desconto": Double} ``` *Um acréscimo é identificado por um
     * desconto com valor negativo.*                                                  |
     * | observacoes             | String: 500 | Informações adicionais que o vendedor registrou
     * no item.
     * 
     * |
     * | excluido                | Boolean     | Indica se o item está excluído.
     * 
     * 
     * |
     * | ipi                     | Double      | Valor do IPI do produto
     * 
     * 
     * |
     * | tipo_ipi                | Char        | Indica se o IPI é percentual P ou valor fixo V
     * 
     * 
     * |
     * | st                      | Double      | Valor da ST (Substituição Tributária)
     * 
     * 
     * |
     * | subtotal                | Double      | Subtotal final calculado
     * 
     * 
     * |
     * #### Estrutura de Retorno de Campos extras do pedido
     * | Campo          | Tipo       | Descrição                           |
     * |----------------|------------|-------------------------------------|
     * | campo_extra_id | Integer    | Identificador único do campo extra. |
     * | nome           | String: 50 | Nome do campo extra.                |
     * | tipo | String| (“0”) Texto livre, (“1”) data, ("2") numérico, ("3") hora, ("4") Lista e
     * ("5") Somente leitura. |
     * | valor_texto    | String: 50 | Retorna um texto se o campo for do tipo texto ou somente
     * leitura. |
     * | valor_data     | String | Retorna uma data se o campo for do tipo data. |
     * | valor_decimal  | Double | Retorna um Double se o campo for do tipo numérico. |
     * | valor_hora     | String | Retorna uma hora o valor se o campo for do tipo texto. |
     * | valor_lista    | List  | Retorna uma lista de Ids e valores dos itens da lista, ex: [[1,
     * "sp"], [2, "sc"]]. |
     * | valor          | | O tipo deste atributo depente do tipo do campo extra como descrito na
     * tabela abaixo. |
     * | Tipo do campo extra | Tipo      | Formato|
     * | --------------------| ----------|--------|
     * | Texto simples("0") | String: 50| |
     * | Data("1") | String | "yyyy-dd-mm", ex: "2018-21-02". |
     * | Numérico("2") | Double | Valor máximo: 99999999.99999. |
     * | Hora("3") | String | "HH:mm",  ex: "21:56".|
     * | Lista("4") | List | Retorna uma lista de Ids e valores dos itens da lista, ex: [[1,
     * "sp"], [2, "sc"]]. |
     * | Somente leitura("5") | String: 50| |
     * #### Estrutura de Envio de Campos extras do pedido
     * Obs: os campos extras cadastrados que não forem enviados serão salvo como vazio.
     * | Campo          | Tipo       | Descrição                           |
     * |----------------|------------|-------------------------------------|
     * | id             | Integer    | Identificador único do campo extra. |
     * | valor          |            | O tipo deste atributo depente do tipo do campo extra como
     * descrito na tabela abaixo.|
     * | Tipo do campo extra | Tipo      | Formato|
     * | --------------------| ----------|--------|
     * | Texto simples("0") | String: 50| |
     * | Data("1") | String | "yyyy-dd-mm", ex: "2018-21-02" |
     * | Numérico("2") | Double | Valor máximo: 99999999.99999 |
     * | Hora("3") | String | "HH:mm",  ex: "21:56"|
     * | Lista("4") | List: int | Lista de ids dos itens selecionados, se atributo lista_multipla
     * for verdadeiro pode ser enviado mais de 1 id na lista. |
     * | Somente leitura("5") | String: 50| |
     * #### Estrutura de Retorno do Endereço de entrega
     * | Campo       | Tipo        | Descrição
     * |
     * |-------------|-------------|--------------------------------------------------------------
     * -----------------------------------|
     * | id          | Integer     | Identificador único do endereço. Este identificador é o
     * mesmo de endereço adicional de cliente. |
     * | cep         | String: 8   | CEP da localização do endereço
     * |
     * | endereco    | String: 200 | Endereço ou rua
     * |
     * | numero      | String: 100 | Número do local
     * |
     * | complemento | String: 200 | Complementos do endereço
     * |
     * | bairro      | String: 200 | Bairro do endereço
     * |
     * | cidade      | String: 200 | Cidade do endereço
     * |
     * | estado      | String: 2   | Estado da cidade
     * |
     *
     * @param {dateTime} alteradoApos Retorna os registros que foram alterados após esta data.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterTodosOsPedidos1(alteradoApos,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v2/pedidos';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            alterado_apos: _apiHelper.stringifyDateTime(alteradoApos, 'date'),
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade Pedidos engloba tanto pedidos realizados quanto orçamentos pendentes.
     * O que diferencia um orçamento de um pedido efetivado é a propriedade status, que pode ser
     * consultado
     * usando GET EX: *https://app.mercos.com/api/v2/pedidos/?alterado_apos=2019-03-01%2007:21:
     * 44&status=2*
     * ### O que mudou da v1 para a v2
     * **GET:**
     * - O campo "items" foi renomeado para "itens".
     * - O campo "descontos" foi removido.
     * - O campo "preco_bruto" foi renomeado para "preco_tabela".
     * - Nos campos "descontos_de_promocoes" e "descontos_de_politicas" é retornada uma lista
     * contendo o ID da regra e o percentual de desconto.
     * **POST:**
     * - O campo "descontos" foi renomeado para "descontos_do_vendedor".
     * - Os campos "descontos_de_promocoes" e "descontos_de_politicas" foram acrescentados.
     * - O campo "preco_bruto" foi renomeado para "preco_tabela".
     * - Os IDs dos itens criados são retornados no corpo da resposta.
     * **PUT:**
     * - O campo "descontos" foi renomeado para "descontos_do_vendedor".
     * - Os campos "descontos_de_promocoes" e "descontos_de_politicas" foram acrescentados.
     * - O campo "preco_bruto" foi renomeado para "preco_tabela".
     * - Os IDs dos itens criados ou atualizados são retornados no corpo da resposta.
     * #### Estrutura de Retorno do Pedido
     * | Campo                      | Tipo        | Descrição
     * |
     * |----------------------------|-------------|-----------------------------------------------
     * -----------------------------------------------------------------------|
     * | id                         | Integer     | Identificador único.
     * |
     * | cliente_id                 | Integer     | Identificador único do cliente.
     * |
     * | cliente_razao_social       | String: 100 | Razão social do cliente
     * |
     * | cliente_nome_fantasia      | String: 100 | Nome fantasia do cliente
     * |
     * | cliente_cnpj               | String: 14  | CNPJ do cliente
     * |
     * | cliente_inscricao_estadual | String: 30  | Inscrição estadual do cliente
     * |
     * | cliente_rua                | String: 100 | Rua do cliente
     * |
     * | cliente_numero             | String: 100 | Número do endereço do cliente
     * |
     * | cliente_complemento        | String: 50  | Complemento do cliente
     * |
     * | cliente_cep                | String: 8   | CEP do cliente
     * |
     * | cliente_bairro             | String: 30  | Bairro do cliente
     * |
     * | cliente_cidade             | String: 50  | Cidade do cliente
     * |
     * | cliente_estado             | String: 2   | Estado do cliente
     * |
     * | cliente_suframa            | String: 20  | Suframa do cliente
     * |
     * | representada_id            | Integer     | ID da Representada
     * |
     * | representada_nome_fantasia | String: 50  | Nome fantasia da Representada
     * |
     * | representada_razao_social  | String: 50  | Razão Social da Representada
     * |
     * | transportadora_id          | Integer     | Identificador único da transportadora.
     * |
     * | criador_id                 | Integer     | Identificador único do vendedor que fez o
     * pedido.                                                                    |
     * | nome_contato               | String: 50  | Nome do contato do cliente.
     * |
     * | status                     | String: 1   | Status atual do pedido. 0 = Cancelado, 1 =
     * Orçamento, 2 = Pedido.                                                    |
     * | numero                     | Integer     | Número auto-incremental do pedido.
     * |
     * | total                      | Double      | Valor total do pedido.
     * |
     * | condicao_pagamento         | String: 100 | Condição de pagamento em formato texto livre.
     * É usado apenas caso você não integre a entidade Condições de Pagamento. |
     * | condicao_pagamento_id      | Integer     | Identificador único da condição de pagamento.
     * É usado apenas caso você integre a entidade Condições de Pagamento.     |
     * | tipo_pedido_id             | Integer     | Identificador único do tipo de pedido.É usado
     * apenas caso você integre a entidade Tipo de Pedido.                    |
     * | forma_pagamento_id         | Integer     | Identificador único da forma de pagamento.É
     * usado apenas caso você integre a entidade Formas de Pagamento.           |
     * | data_emissao               | Date        | Data de emissão do pedido. Pode ser null.
     * |
     * | observacoes                | String: 500 | Informações adicionais que o vendedor
     * registrou no pedido.
     * | status_custom_id           | Integer     | Identificador único do status de pedido
     * customizado. É usado apenas caso você integre a entidade Status de Pedido Customizado.|
     * | status_b2b                 | Integer     | Status atual do pedido no B2b. null = Pedido
     * não foi gerado com o B2B, 1 = Em aberto, 2 = Concluído.                 |
     * #### Estrutura de Retorno do Item do pedido
     * | Campo                   | Tipo        | Descrição
     * 
     * 
     * |
     * |-------------------------|-------------|--------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * -------------------------------------------|
     * | id                      | Integer     | Identificador único do item do pedido.
     * 
     * 
     * |
     * | produto_id              | Integer     | ID do produto na Mercos.
     * 
     * 
     * |
     * | produto_codigo          | String: 50  | Código do Produto na Mercos.
     * 
     * 
     * |
     * | produto_nome            | String: 100 | Nome do Produto na Mercos.
     * 
     * 
     * |
     * | tabela_preco_id         | Integer     | ID da tabela de preço na Mercos. Caso tenha sido
     * utilizado o preço padrão (campo “preco_tabela” da entidade Produto), a tabela_preco_id
     * será null.
     * |
     * | quantidade              | Double      | Quantidade vendida.
     * 
     * 
     * |
     * | preco_tabela            | Double      | Preço padrão do produto no momento da venda
     * (campo “preco_tabela” da entidade Produto) ou caso tenha sido utilizada uma tabela de
     * preço (tabela_preco_id diferente de null) será o valor da tabela de preço utilizada.
     * |
     * | preco_liquido           | Double      | Preço de venda do produto.
     * 
     * 
     * |
     * | cotacao_moeda           | Double      | Cotação da moeda, em caso de venda em moeda
     * estrangeira.
     * 
     * |
     * | quantidade_grades       | List        | Lista com as grades de cores e tamanhos usadas,
     * e suas respectivas quantidades. Caso o produto possua somente Cor, o Tamanho será null, e
     * vice-versa. A soma das quantidades nesta lista será igual ao campo quantidade do item.cor
     * String: 15tamanho String: 15quantidade Double |
     * | descontos_do_vendedor   | List        | Lista com os descontos concedidos pelo vendedor
     * ao item, em formato Double.
     * 
     * |
     * | descontos_de_promocoes  | List        | Lista com os descontos de promoções aplicadas ao
     * item, cada elemento da lista é um objeto no formato: ```{"regra_id": Integer, "desconto":
     * Double}```
     * |
     * | descontos_de_politicas  | List        | Lista com os acréscimos ou descontos de
     * políticas comerciais aplicadas ao item, cada elemento da lista é um objeto no formato:
     * ```{"regra_id": Integer, "desconto": Double} ``` *Um acréscimo é identificado por um
     * desconto com valor negativo.*                                                  |
     * | observacoes             | String: 500 | Informações adicionais que o vendedor registrou
     * no item.
     * 
     * |
     * | excluido                | Boolean     | Indica se o item está excluído.
     * 
     * 
     * |
     * | ipi                     | Double      | Valor do IPI do produto
     * 
     * 
     * |
     * | tipo_ipi                | Char        | Indica se o IPI é percentual P ou valor fixo V
     * 
     * 
     * |
     * | st                      | Double      | Valor da ST (Substituição Tributária)
     * 
     * 
     * |
     * | subtotal                | Double      | Subtotal final calculado
     * 
     * 
     * |
     * #### Estrutura de Retorno de Campos extras do pedido
     * | Campo          | Tipo       | Descrição                           |
     * |----------------|------------|-------------------------------------|
     * | campo_extra_id | Integer    | Identificador único do campo extra. |
     * | nome           | String: 50 | Nome do campo extra.                |
     * | tipo | String| (“0”) Texto livre, (“1”) data, ("2") numérico, ("3") hora, ("4") Lista e
     * ("5") Somente leitura. |
     * | valor_texto    | String: 50 | Retorna um texto se o campo for do tipo texto ou somente
     * leitura. |
     * | valor_data     | String | Retorna uma data se o campo for do tipo data. |
     * | valor_decimal  | Double | Retorna um Double se o campo for do tipo numérico. |
     * | valor_hora     | String | Retorna uma hora o valor se o campo for do tipo texto. |
     * | valor_lista    | List  | Retorna uma lista de Ids e valores dos itens da lista, ex: [[1,
     * "sp"], [2, "sc"]]. |
     * | valor          | | O tipo deste atributo depente do tipo do campo extra como descrito na
     * tabela abaixo. |
     * | Tipo do campo extra | Tipo      | Formato|
     * | --------------------| ----------|--------|
     * | Texto simples("0") | String: 50| |
     * | Data("1") | String | "yyyy-dd-mm", ex: "2018-21-02". |
     * | Numérico("2") | Double | Valor máximo: 99999999.99999. |
     * | Hora("3") | String | "HH:mm",  ex: "21:56".|
     * | Lista("4") | List | Retorna uma lista de Ids e valores dos itens da lista, ex: [[1,
     * "sp"], [2, "sc"]]. |
     * | Somente leitura("5") | String: 50| |
     * #### Estrutura de Envio de Campos extras do pedido
     * Obs: os campos extras cadastrados que não forem enviados serão salvo como vazio.
     * | Campo          | Tipo       | Descrição                           |
     * |----------------|------------|-------------------------------------|
     * | id             | Integer    | Identificador único do campo extra. |
     * | valor          |            | O tipo deste atributo depente do tipo do campo extra como
     * descrito na tabela abaixo.|
     * | Tipo do campo extra | Tipo      | Formato|
     * | --------------------| ----------|--------|
     * | Texto simples("0") | String: 50| |
     * | Data("1") | String | "yyyy-dd-mm", ex: "2018-21-02" |
     * | Numérico("2") | Double | Valor máximo: 99999999.99999 |
     * | Hora("3") | String | "HH:mm",  ex: "21:56"|
     * | Lista("4") | List: int | Lista de ids dos itens selecionados, se atributo lista_multipla
     * for verdadeiro pode ser enviado mais de 1 id na lista. |
     * | Somente leitura("5") | String: 50| |
     * #### Estrutura de Retorno do Endereço de entrega
     * | Campo       | Tipo        | Descrição
     * |
     * |-------------|-------------|--------------------------------------------------------------
     * -----------------------------------|
     * | id          | Integer     | Identificador único do endereço. Este identificador é o
     * mesmo de endereço adicional de cliente. |
     * | cep         | String: 8   | CEP da localização do endereço
     * |
     * | endereco    | String: 200 | Endereço ou rua
     * |
     * | numero      | String: 100 | Número do local
     * |
     * | complemento | String: 200 | Complementos do endereço
     * |
     * | bairro      | String: 200 | Bairro do endereço
     * |
     * | cidade      | String: 200 | Cidade do endereço
     * |
     * | estado      | String: 2   | Estado da cidade
     * |
     *
     * @param {double} id ID do Pedido no sistema Mercos.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterUmPedidoEspecFico1(id, contentType, applicationToken, companyToken, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v2/pedidos/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade Pedidos engloba tanto pedidos realizados quanto orçamentos pendentes.
     * O que diferencia um orçamento de um pedido efetivado é a propriedade status, que pode ser
     * consultado
     * usando GET EX: *https://app.mercos.com/api/v2/pedidos/?alterado_apos=2019-03-01%2007:21:
     * 44&status=2*
     * ### O que mudou da v1 para a v2
     * **GET:**
     * - O campo "items" foi renomeado para "itens".
     * - O campo "descontos" foi removido.
     * - O campo "preco_bruto" foi renomeado para "preco_tabela".
     * - Nos campos "descontos_de_promocoes" e "descontos_de_politicas" é retornada uma lista
     * contendo o ID da regra e o percentual de desconto.
     * **POST:**
     * - O campo "descontos" foi renomeado para "descontos_do_vendedor".
     * - Os campos "descontos_de_promocoes" e "descontos_de_politicas" foram acrescentados.
     * - O campo "preco_bruto" foi renomeado para "preco_tabela".
     * - Os IDs dos itens criados são retornados no corpo da resposta.
     * **PUT:**
     * - O campo "descontos" foi renomeado para "descontos_do_vendedor".
     * - Os campos "descontos_de_promocoes" e "descontos_de_politicas" foram acrescentados.
     * - O campo "preco_bruto" foi renomeado para "preco_tabela".
     * - Os IDs dos itens criados ou atualizados são retornados no corpo da resposta.
     * #### Estrutura de Retorno do Pedido
     * | Campo                      | Tipo        | Descrição
     * |
     * |----------------------------|-------------|-----------------------------------------------
     * -----------------------------------------------------------------------|
     * | id                         | Integer     | Identificador único.
     * |
     * | cliente_id                 | Integer     | Identificador único do cliente.
     * |
     * | cliente_razao_social       | String: 100 | Razão social do cliente
     * |
     * | cliente_nome_fantasia      | String: 100 | Nome fantasia do cliente
     * |
     * | cliente_cnpj               | String: 14  | CNPJ do cliente
     * |
     * | cliente_inscricao_estadual | String: 30  | Inscrição estadual do cliente
     * |
     * | cliente_rua                | String: 100 | Rua do cliente
     * |
     * | cliente_numero             | String: 100 | Número do endereço do cliente
     * |
     * | cliente_complemento        | String: 50  | Complemento do cliente
     * |
     * | cliente_cep                | String: 8   | CEP do cliente
     * |
     * | cliente_bairro             | String: 30  | Bairro do cliente
     * |
     * | cliente_cidade             | String: 50  | Cidade do cliente
     * |
     * | cliente_estado             | String: 2   | Estado do cliente
     * |
     * | cliente_suframa            | String: 20  | Suframa do cliente
     * |
     * | representada_id            | Integer     | ID da Representada
     * |
     * | representada_nome_fantasia | String: 50  | Nome fantasia da Representada
     * |
     * | representada_razao_social  | String: 50  | Razão Social da Representada
     * |
     * | transportadora_id          | Integer     | Identificador único da transportadora.
     * |
     * | criador_id                 | Integer     | Identificador único do vendedor que fez o
     * pedido.                                                                    |
     * | nome_contato               | String: 50  | Nome do contato do cliente.
     * |
     * | status                     | String: 1   | Status atual do pedido. 0 = Cancelado, 1 =
     * Orçamento, 2 = Pedido.                                                    |
     * | numero                     | Integer     | Número auto-incremental do pedido.
     * |
     * | total                      | Double      | Valor total do pedido.
     * |
     * | condicao_pagamento         | String: 100 | Condição de pagamento em formato texto livre.
     * É usado apenas caso você não integre a entidade Condições de Pagamento. |
     * | condicao_pagamento_id      | Integer     | Identificador único da condição de pagamento.
     * É usado apenas caso você integre a entidade Condições de Pagamento.     |
     * | tipo_pedido_id             | Integer     | Identificador único do tipo de pedido.É usado
     * apenas caso você integre a entidade Tipo de Pedido.                    |
     * | forma_pagamento_id         | Integer     | Identificador único da forma de pagamento.É
     * usado apenas caso você integre a entidade Formas de Pagamento.           |
     * | data_emissao               | Date        | Data de emissão do pedido. Pode ser null.
     * |
     * | observacoes                | String: 500 | Informações adicionais que o vendedor
     * registrou no pedido.
     * | status_custom_id           | Integer     | Identificador único do status de pedido
     * customizado. É usado apenas caso você integre a entidade Status de Pedido Customizado.|
     * | status_b2b                 | Integer     | Status atual do pedido no B2b. null = Pedido
     * não foi gerado com o B2B, 1 = Em aberto, 2 = Concluído.                 |
     * #### Estrutura de Retorno do Item do pedido
     * | Campo                   | Tipo        | Descrição
     * 
     * 
     * |
     * |-------------------------|-------------|--------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * -------------------------------------------|
     * | id                      | Integer     | Identificador único do item do pedido.
     * 
     * 
     * |
     * | produto_id              | Integer     | ID do produto na Mercos.
     * 
     * 
     * |
     * | produto_codigo          | String: 50  | Código do Produto na Mercos.
     * 
     * 
     * |
     * | produto_nome            | String: 100 | Nome do Produto na Mercos.
     * 
     * 
     * |
     * | tabela_preco_id         | Integer     | ID da tabela de preço na Mercos. Caso tenha sido
     * utilizado o preço padrão (campo “preco_tabela” da entidade Produto), a tabela_preco_id
     * será null.
     * |
     * | quantidade              | Double      | Quantidade vendida.
     * 
     * 
     * |
     * | preco_tabela            | Double      | Preço padrão do produto no momento da venda
     * (campo “preco_tabela” da entidade Produto) ou caso tenha sido utilizada uma tabela de
     * preço (tabela_preco_id diferente de null) será o valor da tabela de preço utilizada.
     * |
     * | preco_liquido           | Double      | Preço de venda do produto.
     * 
     * 
     * |
     * | cotacao_moeda           | Double      | Cotação da moeda, em caso de venda em moeda
     * estrangeira.
     * 
     * |
     * | quantidade_grades       | List        | Lista com as grades de cores e tamanhos usadas,
     * e suas respectivas quantidades. Caso o produto possua somente Cor, o Tamanho será null, e
     * vice-versa. A soma das quantidades nesta lista será igual ao campo quantidade do item.cor
     * String: 15tamanho String: 15quantidade Double |
     * | descontos_do_vendedor   | List        | Lista com os descontos concedidos pelo vendedor
     * ao item, em formato Double.
     * 
     * |
     * | descontos_de_promocoes  | List        | Lista com os descontos de promoções aplicadas ao
     * item, cada elemento da lista é um objeto no formato: ```{"regra_id": Integer, "desconto":
     * Double}```
     * |
     * | descontos_de_politicas  | List        | Lista com os acréscimos ou descontos de
     * políticas comerciais aplicadas ao item, cada elemento da lista é um objeto no formato:
     * ```{"regra_id": Integer, "desconto": Double} ``` *Um acréscimo é identificado por um
     * desconto com valor negativo.*                                                  |
     * | observacoes             | String: 500 | Informações adicionais que o vendedor registrou
     * no item.
     * 
     * |
     * | excluido                | Boolean     | Indica se o item está excluído.
     * 
     * 
     * |
     * | ipi                     | Double      | Valor do IPI do produto
     * 
     * 
     * |
     * | tipo_ipi                | Char        | Indica se o IPI é percentual P ou valor fixo V
     * 
     * 
     * |
     * | st                      | Double      | Valor da ST (Substituição Tributária)
     * 
     * 
     * |
     * | subtotal                | Double      | Subtotal final calculado
     * 
     * 
     * |
     * #### Estrutura de Retorno de Campos extras do pedido
     * | Campo          | Tipo       | Descrição                           |
     * |----------------|------------|-------------------------------------|
     * | campo_extra_id | Integer    | Identificador único do campo extra. |
     * | nome           | String: 50 | Nome do campo extra.                |
     * | tipo | String| (“0”) Texto livre, (“1”) data, ("2") numérico, ("3") hora, ("4") Lista e
     * ("5") Somente leitura. |
     * | valor_texto    | String: 50 | Retorna um texto se o campo for do tipo texto ou somente
     * leitura. |
     * | valor_data     | String | Retorna uma data se o campo for do tipo data. |
     * | valor_decimal  | Double | Retorna um Double se o campo for do tipo numérico. |
     * | valor_hora     | String | Retorna uma hora o valor se o campo for do tipo texto. |
     * | valor_lista    | List  | Retorna uma lista de Ids e valores dos itens da lista, ex: [[1,
     * "sp"], [2, "sc"]]. |
     * | valor          | | O tipo deste atributo depente do tipo do campo extra como descrito na
     * tabela abaixo. |
     * | Tipo do campo extra | Tipo      | Formato|
     * | --------------------| ----------|--------|
     * | Texto simples("0") | String: 50| |
     * | Data("1") | String | "yyyy-dd-mm", ex: "2018-21-02". |
     * | Numérico("2") | Double | Valor máximo: 99999999.99999. |
     * | Hora("3") | String | "HH:mm",  ex: "21:56".|
     * | Lista("4") | List | Retorna uma lista de Ids e valores dos itens da lista, ex: [[1,
     * "sp"], [2, "sc"]]. |
     * | Somente leitura("5") | String: 50| |
     * #### Estrutura de Envio de Campos extras do pedido
     * Obs: os campos extras cadastrados que não forem enviados serão salvo como vazio.
     * | Campo          | Tipo       | Descrição                           |
     * |----------------|------------|-------------------------------------|
     * | id             | Integer    | Identificador único do campo extra. |
     * | valor          |            | O tipo deste atributo depente do tipo do campo extra como
     * descrito na tabela abaixo.|
     * | Tipo do campo extra | Tipo      | Formato|
     * | --------------------| ----------|--------|
     * | Texto simples("0") | String: 50| |
     * | Data("1") | String | "yyyy-dd-mm", ex: "2018-21-02" |
     * | Numérico("2") | Double | Valor máximo: 99999999.99999 |
     * | Hora("3") | String | "HH:mm",  ex: "21:56"|
     * | Lista("4") | List: int | Lista de ids dos itens selecionados, se atributo lista_multipla
     * for verdadeiro pode ser enviado mais de 1 id na lista. |
     * | Somente leitura("5") | String: 50| |
     * #### Estrutura de Retorno do Endereço de entrega
     * | Campo       | Tipo        | Descrição
     * |
     * |-------------|-------------|--------------------------------------------------------------
     * -----------------------------------|
     * | id          | Integer     | Identificador único do endereço. Este identificador é o
     * mesmo de endereço adicional de cliente. |
     * | cep         | String: 8   | CEP da localização do endereço
     * |
     * | endereco    | String: 200 | Endereço ou rua
     * |
     * | numero      | String: 100 | Número do local
     * |
     * | complemento | String: 200 | Complementos do endereço
     * |
     * | bairro      | String: 200 | Bairro do endereço
     * |
     * | cidade      | String: 200 | Cidade do endereço
     * |
     * | estado      | String: 2   | Estado da cidade
     * |
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {IncluirUmPedidoRequest2} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createIncluirUmPedido1(contentType, applicationToken, companyToken, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v2/pedidos';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'IncluirUmPedidoResponse');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'IncluirUmPedido412Response1Exception');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade Pedidos engloba tanto pedidos realizados quanto orçamentos pendentes.
     * O que diferencia um orçamento de um pedido efetivado é a propriedade status, que pode ser
     * consultado
     * usando GET EX: *https://app.mercos.com/api/v2/pedidos/?alterado_apos=2019-03-01%2007:21:
     * 44&status=2*
     * ### O que mudou da v1 para a v2
     * **GET:**
     * - O campo "items" foi renomeado para "itens".
     * - O campo "descontos" foi removido.
     * - O campo "preco_bruto" foi renomeado para "preco_tabela".
     * - Nos campos "descontos_de_promocoes" e "descontos_de_politicas" é retornada uma lista
     * contendo o ID da regra e o percentual de desconto.
     * **POST:**
     * - O campo "descontos" foi renomeado para "descontos_do_vendedor".
     * - Os campos "descontos_de_promocoes" e "descontos_de_politicas" foram acrescentados.
     * - O campo "preco_bruto" foi renomeado para "preco_tabela".
     * - Os IDs dos itens criados são retornados no corpo da resposta.
     * **PUT:**
     * - O campo "descontos" foi renomeado para "descontos_do_vendedor".
     * - Os campos "descontos_de_promocoes" e "descontos_de_politicas" foram acrescentados.
     * - O campo "preco_bruto" foi renomeado para "preco_tabela".
     * - Os IDs dos itens criados ou atualizados são retornados no corpo da resposta.
     * #### Estrutura de Retorno do Pedido
     * | Campo                      | Tipo        | Descrição
     * |
     * |----------------------------|-------------|-----------------------------------------------
     * -----------------------------------------------------------------------|
     * | id                         | Integer     | Identificador único.
     * |
     * | cliente_id                 | Integer     | Identificador único do cliente.
     * |
     * | cliente_razao_social       | String: 100 | Razão social do cliente
     * |
     * | cliente_nome_fantasia      | String: 100 | Nome fantasia do cliente
     * |
     * | cliente_cnpj               | String: 14  | CNPJ do cliente
     * |
     * | cliente_inscricao_estadual | String: 30  | Inscrição estadual do cliente
     * |
     * | cliente_rua                | String: 100 | Rua do cliente
     * |
     * | cliente_numero             | String: 100 | Número do endereço do cliente
     * |
     * | cliente_complemento        | String: 50  | Complemento do cliente
     * |
     * | cliente_cep                | String: 8   | CEP do cliente
     * |
     * | cliente_bairro             | String: 30  | Bairro do cliente
     * |
     * | cliente_cidade             | String: 50  | Cidade do cliente
     * |
     * | cliente_estado             | String: 2   | Estado do cliente
     * |
     * | cliente_suframa            | String: 20  | Suframa do cliente
     * |
     * | representada_id            | Integer     | ID da Representada
     * |
     * | representada_nome_fantasia | String: 50  | Nome fantasia da Representada
     * |
     * | representada_razao_social  | String: 50  | Razão Social da Representada
     * |
     * | transportadora_id          | Integer     | Identificador único da transportadora.
     * |
     * | criador_id                 | Integer     | Identificador único do vendedor que fez o
     * pedido.                                                                    |
     * | nome_contato               | String: 50  | Nome do contato do cliente.
     * |
     * | status                     | String: 1   | Status atual do pedido. 0 = Cancelado, 1 =
     * Orçamento, 2 = Pedido.                                                    |
     * | numero                     | Integer     | Número auto-incremental do pedido.
     * |
     * | total                      | Double      | Valor total do pedido.
     * |
     * | condicao_pagamento         | String: 100 | Condição de pagamento em formato texto livre.
     * É usado apenas caso você não integre a entidade Condições de Pagamento. |
     * | condicao_pagamento_id      | Integer     | Identificador único da condição de pagamento.
     * É usado apenas caso você integre a entidade Condições de Pagamento.     |
     * | tipo_pedido_id             | Integer     | Identificador único do tipo de pedido.É usado
     * apenas caso você integre a entidade Tipo de Pedido.                    |
     * | forma_pagamento_id         | Integer     | Identificador único da forma de pagamento.É
     * usado apenas caso você integre a entidade Formas de Pagamento.           |
     * | data_emissao               | Date        | Data de emissão do pedido. Pode ser null.
     * |
     * | observacoes                | String: 500 | Informações adicionais que o vendedor
     * registrou no pedido.
     * | status_custom_id           | Integer     | Identificador único do status de pedido
     * customizado. É usado apenas caso você integre a entidade Status de Pedido Customizado.|
     * | status_b2b                 | Integer     | Status atual do pedido no B2b. null = Pedido
     * não foi gerado com o B2B, 1 = Em aberto, 2 = Concluído.                 |
     * #### Estrutura de Retorno do Item do pedido
     * | Campo                   | Tipo        | Descrição
     * 
     * 
     * |
     * |-------------------------|-------------|--------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * -------------------------------------------|
     * | id                      | Integer     | Identificador único do item do pedido.
     * 
     * 
     * |
     * | produto_id              | Integer     | ID do produto na Mercos.
     * 
     * 
     * |
     * | produto_codigo          | String: 50  | Código do Produto na Mercos.
     * 
     * 
     * |
     * | produto_nome            | String: 100 | Nome do Produto na Mercos.
     * 
     * 
     * |
     * | tabela_preco_id         | Integer     | ID da tabela de preço na Mercos. Caso tenha sido
     * utilizado o preço padrão (campo “preco_tabela” da entidade Produto), a tabela_preco_id
     * será null.
     * |
     * | quantidade              | Double      | Quantidade vendida.
     * 
     * 
     * |
     * | preco_tabela            | Double      | Preço padrão do produto no momento da venda
     * (campo “preco_tabela” da entidade Produto) ou caso tenha sido utilizada uma tabela de
     * preço (tabela_preco_id diferente de null) será o valor da tabela de preço utilizada.
     * |
     * | preco_liquido           | Double      | Preço de venda do produto.
     * 
     * 
     * |
     * | cotacao_moeda           | Double      | Cotação da moeda, em caso de venda em moeda
     * estrangeira.
     * 
     * |
     * | quantidade_grades       | List        | Lista com as grades de cores e tamanhos usadas,
     * e suas respectivas quantidades. Caso o produto possua somente Cor, o Tamanho será null, e
     * vice-versa. A soma das quantidades nesta lista será igual ao campo quantidade do item.cor
     * String: 15tamanho String: 15quantidade Double |
     * | descontos_do_vendedor   | List        | Lista com os descontos concedidos pelo vendedor
     * ao item, em formato Double.
     * 
     * |
     * | descontos_de_promocoes  | List        | Lista com os descontos de promoções aplicadas ao
     * item, cada elemento da lista é um objeto no formato: ```{"regra_id": Integer, "desconto":
     * Double}```
     * |
     * | descontos_de_politicas  | List        | Lista com os acréscimos ou descontos de
     * políticas comerciais aplicadas ao item, cada elemento da lista é um objeto no formato:
     * ```{"regra_id": Integer, "desconto": Double} ``` *Um acréscimo é identificado por um
     * desconto com valor negativo.*                                                  |
     * | observacoes             | String: 500 | Informações adicionais que o vendedor registrou
     * no item.
     * 
     * |
     * | excluido                | Boolean     | Indica se o item está excluído.
     * 
     * 
     * |
     * | ipi                     | Double      | Valor do IPI do produto
     * 
     * 
     * |
     * | tipo_ipi                | Char        | Indica se o IPI é percentual P ou valor fixo V
     * 
     * 
     * |
     * | st                      | Double      | Valor da ST (Substituição Tributária)
     * 
     * 
     * |
     * | subtotal                | Double      | Subtotal final calculado
     * 
     * 
     * |
     * #### Estrutura de Retorno de Campos extras do pedido
     * | Campo          | Tipo       | Descrição                           |
     * |----------------|------------|-------------------------------------|
     * | campo_extra_id | Integer    | Identificador único do campo extra. |
     * | nome           | String: 50 | Nome do campo extra.                |
     * | tipo | String| (“0”) Texto livre, (“1”) data, ("2") numérico, ("3") hora, ("4") Lista e
     * ("5") Somente leitura. |
     * | valor_texto    | String: 50 | Retorna um texto se o campo for do tipo texto ou somente
     * leitura. |
     * | valor_data     | String | Retorna uma data se o campo for do tipo data. |
     * | valor_decimal  | Double | Retorna um Double se o campo for do tipo numérico. |
     * | valor_hora     | String | Retorna uma hora o valor se o campo for do tipo texto. |
     * | valor_lista    | List  | Retorna uma lista de Ids e valores dos itens da lista, ex: [[1,
     * "sp"], [2, "sc"]]. |
     * | valor          | | O tipo deste atributo depente do tipo do campo extra como descrito na
     * tabela abaixo. |
     * | Tipo do campo extra | Tipo      | Formato|
     * | --------------------| ----------|--------|
     * | Texto simples("0") | String: 50| |
     * | Data("1") | String | "yyyy-dd-mm", ex: "2018-21-02". |
     * | Numérico("2") | Double | Valor máximo: 99999999.99999. |
     * | Hora("3") | String | "HH:mm",  ex: "21:56".|
     * | Lista("4") | List | Retorna uma lista de Ids e valores dos itens da lista, ex: [[1,
     * "sp"], [2, "sc"]]. |
     * | Somente leitura("5") | String: 50| |
     * #### Estrutura de Envio de Campos extras do pedido
     * Obs: os campos extras cadastrados que não forem enviados serão salvo como vazio.
     * | Campo          | Tipo       | Descrição                           |
     * |----------------|------------|-------------------------------------|
     * | id             | Integer    | Identificador único do campo extra. |
     * | valor          |            | O tipo deste atributo depente do tipo do campo extra como
     * descrito na tabela abaixo.|
     * | Tipo do campo extra | Tipo      | Formato|
     * | --------------------| ----------|--------|
     * | Texto simples("0") | String: 50| |
     * | Data("1") | String | "yyyy-dd-mm", ex: "2018-21-02" |
     * | Numérico("2") | Double | Valor máximo: 99999999.99999 |
     * | Hora("3") | String | "HH:mm",  ex: "21:56"|
     * | Lista("4") | List: int | Lista de ids dos itens selecionados, se atributo lista_multipla
     * for verdadeiro pode ser enviado mais de 1 id na lista. |
     * | Somente leitura("5") | String: 50| |
     * #### Estrutura de Retorno do Endereço de entrega
     * | Campo       | Tipo        | Descrição
     * |
     * |-------------|-------------|--------------------------------------------------------------
     * -----------------------------------|
     * | id          | Integer     | Identificador único do endereço. Este identificador é o
     * mesmo de endereço adicional de cliente. |
     * | cep         | String: 8   | CEP da localização do endereço
     * |
     * | endereco    | String: 200 | Endereço ou rua
     * |
     * | numero      | String: 100 | Número do local
     * |
     * | complemento | String: 200 | Complementos do endereço
     * |
     * | bairro      | String: 200 | Bairro do endereço
     * |
     * | cidade      | String: 200 | Cidade do endereço
     * |
     * | estado      | String: 2   | Estado da cidade
     * |
     *
     * @param {double} id ID do Pedido no sistema Mercos.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {AlterarUmPedidoRequest2} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static alterarUmPedido1(id, contentType, applicationToken, companyToken, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v2/pedidos/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'AlterarUmPedidoResponse');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'AlterarUmPedido412Response1Exception');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Este endpoint permite realizar o cancelamento de pedidos.
     *
     * @param {double} id ID do Pedido no sistema Mercos.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createCancelarUmPedido(id, contentType, applicationToken, companyToken, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/pedidos/cancelar/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'CancelarUmPedido412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade status de pedido permite incluir, alterar e excluir os status que os pedidos no
     * Mercos poderão ter.
     * #### Estrutura de Retorno do GET
     * | Campo            | Tipo        | Descrição
     * |
     * |------------------|-------------|---------------------------------------------------------
     * -|
     * | id               | Integer     | Identificador único
     * |
     * | nome             | String: 100 | Nome do status
     * |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação deste status no
     * Mercos |
     * | excluido         | Boolean     | Indica se o status está excluído
     * |
     *
     * @param {dateTime} alteradoApos Retorna os registros que foram alterados após esta data.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterTodosOsStatus(alteradoApos,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/pedidos/status';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            alterado_apos: _apiHelper.stringifyDateTime(alteradoApos, 'date'),
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade status de pedido permite incluir, alterar e excluir os status que os pedidos no
     * Mercos poderão ter.
     * #### Estrutura de Retorno do GET
     * | Campo            | Tipo        | Descrição
     * |
     * |------------------|-------------|---------------------------------------------------------
     * -|
     * | id               | Integer     | Identificador único
     * |
     * | nome             | String: 100 | Nome do status
     * |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação deste status no
     * Mercos |
     * | excluido         | Boolean     | Indica se o status está excluído
     * |
     *
     * @param {double} id ID do Status no sistema Mercos.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterStatusEspecFico(id, contentType, applicationToken, companyToken, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/pedidos/status/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade status de pedido permite incluir, alterar e excluir os status que os pedidos no
     * Mercos poderão ter.
     * #### Estrutura de Retorno do GET
     * | Campo            | Tipo        | Descrição
     * |
     * |------------------|-------------|---------------------------------------------------------
     * -|
     * | id               | Integer     | Identificador único
     * |
     * | nome             | String: 100 | Nome do status
     * |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação deste status no
     * Mercos |
     * | excluido         | Boolean     | Indica se o status está excluído
     * |
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {CadastrarStatusRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createCadastrarStatus(contentType, applicationToken, companyToken, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/pedidos/status';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'CadastrarStatus412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade status de pedido permite incluir, alterar e excluir os status que os pedidos no
     * Mercos poderão ter.
     * #### Estrutura de Retorno do GET
     * | Campo            | Tipo        | Descrição
     * |
     * |------------------|-------------|---------------------------------------------------------
     * -|
     * | id               | Integer     | Identificador único
     * |
     * | nome             | String: 100 | Nome do status
     * |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação deste status no
     * Mercos |
     * | excluido         | Boolean     | Indica se o status está excluído
     * |
     *
     * @param {double} id ID do Status no sistema Mercos.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {AlterarUmStatusRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static alterarUmStatus(id, contentType, applicationToken, companyToken, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/pedidos/status/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'AlterarUmStatus412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade status de pedido permite incluir, alterar e excluir os status que os pedidos no
     * Mercos poderão ter.
     * #### Estrutura de Retorno do GET
     * | Campo            | Tipo        | Descrição
     * |
     * |------------------|-------------|---------------------------------------------------------
     * -|
     * | id               | Integer     | Identificador único
     * |
     * | nome             | String: 100 | Nome do status
     * |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação deste status no
     * Mercos |
     * | excluido         | Boolean     | Indica se o status está excluído
     * |
     *
     * @param {double} id ID do Pedido no sistema Mercos.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {AlterarStatusDeUmPedidoRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static alterarStatusDeUmPedido(id,
        contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/pedidos/{id}/status';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'AlterarStatusDeUmPedido412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade status de pedido permite incluir, alterar e excluir os status que os pedidos no
     * Mercos poderão ter.
     * #### Estrutura de Retorno do GET
     * | Campo            | Tipo        | Descrição
     * |
     * |------------------|-------------|---------------------------------------------------------
     * -|
     * | id               | Integer     | Identificador único
     * |
     * | nome             | String: 100 | Nome do status
     * |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação deste status no
     * Mercos |
     * | excluido         | Boolean     | Indica se o status está excluído
     * |
     *
     * @param {double} id ID do Pedido no sistema Mercos.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterHistRicoDeStatusDeUmPedido(id,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/pedidos/{id}/status';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade tipo de pedido permite incluir, alterar e excluir os tipos de pedido.
     * #### Estrutura de Retorno do GET
     * | Campo            | Tipo       | Descrição
     * |
     * |------------------|------------|--------------------------------------------------------
     * |
     * | id               | Integer    | Identificador único
     * |
     * | nome             | String: 50 | Nome do tipo de pedido
     * |
     * | ultima_alteracao | DateTime   | Data e hora da última modificação deste tipo no Mercos
     * |
     *
     * @param {dateTime} alteradoApos Retorna os registros que foram alterados após esta data.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterTodosOsTiposDePedido(alteradoApos,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/pedidos/tipo';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            alterado_apos: _apiHelper.stringifyDateTime(alteradoApos, 'date'),
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade tipo de pedido permite incluir, alterar e excluir os tipos de pedido.
     * #### Estrutura de Retorno do GET
     * | Campo            | Tipo       | Descrição
     * |
     * |------------------|------------|--------------------------------------------------------
     * |
     * | id               | Integer    | Identificador único
     * |
     * | nome             | String: 50 | Nome do tipo de pedido
     * |
     * | ultima_alteracao | DateTime   | Data e hora da última modificação deste tipo no Mercos
     * |
     *
     * @param {double} id ID do Tipo de pedido no sistema Mercos.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterTipoDePedidoEspecFico(id,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/pedidos/tipo/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade tipo de pedido permite incluir, alterar e excluir os tipos de pedido.
     * #### Estrutura de Retorno do GET
     * | Campo            | Tipo       | Descrição
     * |
     * |------------------|------------|--------------------------------------------------------
     * |
     * | id               | Integer    | Identificador único
     * |
     * | nome             | String: 50 | Nome do tipo de pedido
     * |
     * | ultima_alteracao | DateTime   | Data e hora da última modificação deste tipo no Mercos
     * |
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {CadastrarTipoDePedidoRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createCadastrarTipoDePedido(contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/pedidos/tipo';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'CadastrarTipoDePedido412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade tipo de pedido permite incluir, alterar e excluir os tipos de pedido.
     * #### Estrutura de Retorno do GET
     * | Campo            | Tipo       | Descrição
     * |
     * |------------------|------------|--------------------------------------------------------
     * |
     * | id               | Integer    | Identificador único
     * |
     * | nome             | String: 50 | Nome do tipo de pedido
     * |
     * | ultima_alteracao | DateTime   | Data e hora da última modificação deste tipo no Mercos
     * |
     *
     * @param {double} id ID do Tipo de pedido no sistema Mercos.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {AlterarUmTipoDePedidoRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static alterarUmTipoDePedido(id,
        contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/pedidos/tipo/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'AlterarUmTipoDePedido412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Os campos extras são utilizados para anotar no pedido informações relevantes para a
     * empresa ou para o integrador, por exemplo, "data da entrega" e "tipo de frete". Os campos
     * extras podem ser dos seguintes tipos: texto livre, data, hora ou número.
     * #### Estrutura de Retorno do GET
     * | Campo | Tipo       | Descrição                           |
     * |-------|------------|-------------------------------------|
     * | id    | Integer    | Identificador único do campo extra. |
     * | tipo  | String     | (“0”) Texto livre, (“1”) data, ("2") numérico, ("3") hora, ("4")
     * Lista |
     * | nome  | String: 50 | Nome do campo extra.                |
     * | obrigatorio    | Boolean    | Indica obrigatoriedade do campo extra.  |
     * | casas_decimais | Integer | Quantidade de casas decimais, valores suportados de 0 a 5.
     * Esta informação será ignorada se o tipo do campo não for numérico. |
     * | formato| String | ("0") sem formatação, ("1") monetário 'R$', ("2") porcentagem '%'.
     * Esta informação será ignorada se o tipo do campo não for numérico. |
     * | exibir_para_cliente | Boolean | Indica se o valor preenchido para o campo será exibido
     * para o cliente na visualização do pedido. |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação deste registro no
     * Mercos |
     * | excluido         | Boolean    | Indica se o campo está excluído.
     * | lista_multipla | Boolean | Indica se é uma lista simples ou múltipla. |
     * | itens | List: 100 | Lista de itens |
     * #### Estrutura de retorno dos itens
     * | Campo | Tipo       | Descrição                           |
     * |-------|------------|-------------------------------------|
     * | id    | Integer    | Identificador único dos itens de campo extra. |
     * | campo_custom_id | Integer | Identificador único do campo extra. |
     * | ordem | Integer | Ordem do item na lista. |
     * | valor | String: 100 | Valor do item. |
     * | selecionado | Boolean | Indica se esse item já vem pré-selecionado. |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação deste registro no
     * Mercos |
     * | excluido | Boolean    | Indica se o campo está excluído.
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterTodosOsCamposExtras(contentType, applicationToken, companyToken, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/campos_extras';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Os campos extras são utilizados para anotar no pedido informações relevantes para a
     * empresa ou para o integrador, por exemplo, "data da entrega" e "tipo de frete". Os campos
     * extras podem ser dos seguintes tipos: texto livre, data, hora ou número.
     * #### Estrutura de Retorno do GET
     * | Campo | Tipo       | Descrição                           |
     * |-------|------------|-------------------------------------|
     * | id    | Integer    | Identificador único do campo extra. |
     * | tipo  | String     | (“0”) Texto livre, (“1”) data, ("2") numérico, ("3") hora, ("4")
     * Lista |
     * | nome  | String: 50 | Nome do campo extra.                |
     * | obrigatorio    | Boolean    | Indica obrigatoriedade do campo extra.  |
     * | casas_decimais | Integer | Quantidade de casas decimais, valores suportados de 0 a 5.
     * Esta informação será ignorada se o tipo do campo não for numérico. |
     * | formato| String | ("0") sem formatação, ("1") monetário 'R$', ("2") porcentagem '%'.
     * Esta informação será ignorada se o tipo do campo não for numérico. |
     * | exibir_para_cliente | Boolean | Indica se o valor preenchido para o campo será exibido
     * para o cliente na visualização do pedido. |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação deste registro no
     * Mercos |
     * | excluido         | Boolean    | Indica se o campo está excluído.
     * | lista_multipla | Boolean | Indica se é uma lista simples ou múltipla. |
     * | itens | List: 100 | Lista de itens |
     * #### Estrutura de retorno dos itens
     * | Campo | Tipo       | Descrição                           |
     * |-------|------------|-------------------------------------|
     * | id    | Integer    | Identificador único dos itens de campo extra. |
     * | campo_custom_id | Integer | Identificador único do campo extra. |
     * | ordem | Integer | Ordem do item na lista. |
     * | valor | String: 100 | Valor do item. |
     * | selecionado | Boolean | Indica se esse item já vem pré-selecionado. |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação deste registro no
     * Mercos |
     * | excluido | Boolean    | Indica se o campo está excluído.
     *
     * @param {double} id ID do Campo Extra no sistema Mercos.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterUmCampoExtra(id, contentType, applicationToken, companyToken, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/campos_extras/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Os campos extras são utilizados para anotar no pedido informações relevantes para a
     * empresa ou para o integrador, por exemplo, "data da entrega" e "tipo de frete". Os campos
     * extras podem ser dos seguintes tipos: texto livre, data, hora ou número.
     * #### Estrutura de Retorno do GET
     * | Campo | Tipo       | Descrição                           |
     * |-------|------------|-------------------------------------|
     * | id    | Integer    | Identificador único do campo extra. |
     * | tipo  | String     | (“0”) Texto livre, (“1”) data, ("2") numérico, ("3") hora, ("4")
     * Lista |
     * | nome  | String: 50 | Nome do campo extra.                |
     * | obrigatorio    | Boolean    | Indica obrigatoriedade do campo extra.  |
     * | casas_decimais | Integer | Quantidade de casas decimais, valores suportados de 0 a 5.
     * Esta informação será ignorada se o tipo do campo não for numérico. |
     * | formato| String | ("0") sem formatação, ("1") monetário 'R$', ("2") porcentagem '%'.
     * Esta informação será ignorada se o tipo do campo não for numérico. |
     * | exibir_para_cliente | Boolean | Indica se o valor preenchido para o campo será exibido
     * para o cliente na visualização do pedido. |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação deste registro no
     * Mercos |
     * | excluido         | Boolean    | Indica se o campo está excluído.
     * | lista_multipla | Boolean | Indica se é uma lista simples ou múltipla. |
     * | itens | List: 100 | Lista de itens |
     * #### Estrutura de retorno dos itens
     * | Campo | Tipo       | Descrição                           |
     * |-------|------------|-------------------------------------|
     * | id    | Integer    | Identificador único dos itens de campo extra. |
     * | campo_custom_id | Integer | Identificador único do campo extra. |
     * | ordem | Integer | Ordem do item na lista. |
     * | valor | String: 100 | Valor do item. |
     * | selecionado | Boolean | Indica se esse item já vem pré-selecionado. |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação deste registro no
     * Mercos |
     * | excluido | Boolean    | Indica se o campo está excluído.
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {IncluirUmCampoExtraRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createIncluirUmCampoExtra(contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/campos_extras';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'IncluirUmCampoExtraResponse');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'IncluirUmCampoExtra412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Os campos extras são utilizados para anotar no pedido informações relevantes para a
     * empresa ou para o integrador, por exemplo, "data da entrega" e "tipo de frete". Os campos
     * extras podem ser dos seguintes tipos: texto livre, data, hora ou número.
     * #### Estrutura de Retorno do GET
     * | Campo | Tipo       | Descrição                           |
     * |-------|------------|-------------------------------------|
     * | id    | Integer    | Identificador único do campo extra. |
     * | tipo  | String     | (“0”) Texto livre, (“1”) data, ("2") numérico, ("3") hora, ("4")
     * Lista |
     * | nome  | String: 50 | Nome do campo extra.                |
     * | obrigatorio    | Boolean    | Indica obrigatoriedade do campo extra.  |
     * | casas_decimais | Integer | Quantidade de casas decimais, valores suportados de 0 a 5.
     * Esta informação será ignorada se o tipo do campo não for numérico. |
     * | formato| String | ("0") sem formatação, ("1") monetário 'R$', ("2") porcentagem '%'.
     * Esta informação será ignorada se o tipo do campo não for numérico. |
     * | exibir_para_cliente | Boolean | Indica se o valor preenchido para o campo será exibido
     * para o cliente na visualização do pedido. |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação deste registro no
     * Mercos |
     * | excluido         | Boolean    | Indica se o campo está excluído.
     * | lista_multipla | Boolean | Indica se é uma lista simples ou múltipla. |
     * | itens | List: 100 | Lista de itens |
     * #### Estrutura de retorno dos itens
     * | Campo | Tipo       | Descrição                           |
     * |-------|------------|-------------------------------------|
     * | id    | Integer    | Identificador único dos itens de campo extra. |
     * | campo_custom_id | Integer | Identificador único do campo extra. |
     * | ordem | Integer | Ordem do item na lista. |
     * | valor | String: 100 | Valor do item. |
     * | selecionado | Boolean | Indica se esse item já vem pré-selecionado. |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação deste registro no
     * Mercos |
     * | excluido | Boolean    | Indica se o campo está excluído.*Obs: O cadastro dos itens
     * respeita a ordem que foram enviados para gerar o retorno dos ids. O valor máximo de itens
     * que podem ser carastrados é 100*
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {object} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createIncluirUmCampoExtraDoTipoLista(contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/campos_extras';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper()
                .mapObject(parsed, 'IncluirUmCampoExtraDoTipoListaResponse');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'IncluirUmCampoExtraDoTipoLista412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Os campos extras são utilizados para anotar no pedido informações relevantes para a
     * empresa ou para o integrador, por exemplo, "data da entrega" e "tipo de frete". Os campos
     * extras podem ser dos seguintes tipos: texto livre, data, hora ou número.
     * #### Estrutura de Retorno do GET
     * | Campo | Tipo       | Descrição                           |
     * |-------|------------|-------------------------------------|
     * | id    | Integer    | Identificador único do campo extra. |
     * | tipo  | String     | (“0”) Texto livre, (“1”) data, ("2") numérico, ("3") hora, ("4")
     * Lista |
     * | nome  | String: 50 | Nome do campo extra.                |
     * | obrigatorio    | Boolean    | Indica obrigatoriedade do campo extra.  |
     * | casas_decimais | Integer | Quantidade de casas decimais, valores suportados de 0 a 5.
     * Esta informação será ignorada se o tipo do campo não for numérico. |
     * | formato| String | ("0") sem formatação, ("1") monetário 'R$', ("2") porcentagem '%'.
     * Esta informação será ignorada se o tipo do campo não for numérico. |
     * | exibir_para_cliente | Boolean | Indica se o valor preenchido para o campo será exibido
     * para o cliente na visualização do pedido. |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação deste registro no
     * Mercos |
     * | excluido         | Boolean    | Indica se o campo está excluído.
     * | lista_multipla | Boolean | Indica se é uma lista simples ou múltipla. |
     * | itens | List: 100 | Lista de itens |
     * #### Estrutura de retorno dos itens
     * | Campo | Tipo       | Descrição                           |
     * |-------|------------|-------------------------------------|
     * | id    | Integer    | Identificador único dos itens de campo extra. |
     * | campo_custom_id | Integer | Identificador único do campo extra. |
     * | ordem | Integer | Ordem do item na lista. |
     * | valor | String: 100 | Valor do item. |
     * | selecionado | Boolean | Indica se esse item já vem pré-selecionado. |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação deste registro no
     * Mercos |
     * | excluido | Boolean    | Indica se o campo está excluído.
     *
     * @param {double} id ID do Campo Extra no sistema Mercos.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {AlterarUmCampoExtraRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static alterarUmCampoExtra(id, contentType, applicationToken, companyToken, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/campos_extras/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper().mapObject(parsed, 'AlterarUmCampoExtraResponse');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'AlterarUmCampoExtra412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Os campos extras são utilizados para anotar no pedido informações relevantes para a
     * empresa ou para o integrador, por exemplo, "data da entrega" e "tipo de frete". Os campos
     * extras podem ser dos seguintes tipos: texto livre, data, hora ou número.
     * #### Estrutura de Retorno do GET
     * | Campo | Tipo       | Descrição                           |
     * |-------|------------|-------------------------------------|
     * | id    | Integer    | Identificador único do campo extra. |
     * | tipo  | String     | (“0”) Texto livre, (“1”) data, ("2") numérico, ("3") hora, ("4")
     * Lista |
     * | nome  | String: 50 | Nome do campo extra.                |
     * | obrigatorio    | Boolean    | Indica obrigatoriedade do campo extra.  |
     * | casas_decimais | Integer | Quantidade de casas decimais, valores suportados de 0 a 5.
     * Esta informação será ignorada se o tipo do campo não for numérico. |
     * | formato| String | ("0") sem formatação, ("1") monetário 'R$', ("2") porcentagem '%'.
     * Esta informação será ignorada se o tipo do campo não for numérico. |
     * | exibir_para_cliente | Boolean | Indica se o valor preenchido para o campo será exibido
     * para o cliente na visualização do pedido. |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação deste registro no
     * Mercos |
     * | excluido         | Boolean    | Indica se o campo está excluído.
     * | lista_multipla | Boolean | Indica se é uma lista simples ou múltipla. |
     * | itens | List: 100 | Lista de itens |
     * #### Estrutura de retorno dos itens
     * | Campo | Tipo       | Descrição                           |
     * |-------|------------|-------------------------------------|
     * | id    | Integer    | Identificador único dos itens de campo extra. |
     * | campo_custom_id | Integer | Identificador único do campo extra. |
     * | ordem | Integer | Ordem do item na lista. |
     * | valor | String: 100 | Valor do item. |
     * | selecionado | Boolean | Indica se esse item já vem pré-selecionado. |
     * | ultima_alteracao | DateTime    | Data e hora da última modificação deste registro no
     * Mercos |
     * | excluido | Boolean    | Indica se o campo está excluído.*Obs: Na alteração dos itens se
     * não for enviado um id será criado um item novo, quando enviado id será alterado o item
     * existente. A alteração dos itens respeita a ordem que foram enviados para gerar o retorno
     * dos ids.*
     *
     * @param {double} id ID do Campo Extra no sistema Mercos.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {object} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static alterarUmCampoExtraDoTipoLista(id,
        contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/campos_extras/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            accept: 'application/json',
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    let parsed = JSON.parse(_response.body);
                    parsed = _baseController.getObjectMapper()
                .mapObject(parsed, 'AlterarUmCampoExtraDoTipoListaResponse');
                    _callback(null, parsed, _context);
                    _fulfill(parsed);
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'AlterarUmCampoExtraDoTipoLista412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Faturar um pedido, gerando assim comissão aos vendedores.
     * OBS: Caso for necessário excluir o faturamento, deve ser enviado o campo excluido=true no
     * json do PUT de alteração..
     * #### Parâmetros do JSON de envio
     * | Campo                         | Tipo                                 | Descrição
     * |
     * |-------------------------------|--------------------------------------|-------------------
     * -------------------------------------------------------------------------|
     * | pedido_id(obrigatório)        | Integer                              | ID do pedido
     * faturado. Este deve ser o ID cadastrado no Mercos, e não o ID do seu sistema. |
     * | valor_faturado(obrigatório)   | Decimal: 9 dígitos, 2 casas decimais | Valor faturado do
     * pedido.                                                                  |
     * | data_faturamento(obrigatório) | String: “AAAA-MM-DD”                 | Data em que o
     * faturamento foi realizado.                                                   |
     * | numero_nf                     | String: 500                          | Número da nota
     * fiscal.                                                                     |
     * | informacoes_adicionais        | String: 500                          | Informações
     * adicionais referente ao faturamento.                                           |
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {FaturarUmPedidoRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createFaturarUmPedido(contentType, applicationToken, companyToken, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/faturamento';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'FaturarUmPedido412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Faturar um pedido, gerando assim comissão aos vendedores.
     * OBS: Caso for necessário excluir o faturamento, deve ser enviado o campo excluido=true no
     * json do PUT de alteração..
     * #### Parâmetros do JSON de envio
     * | Campo                         | Tipo                                 | Descrição
     * |
     * |-------------------------------|--------------------------------------|-------------------
     * -------------------------------------------------------------------------|
     * | pedido_id(obrigatório)        | Integer                              | ID do pedido
     * faturado. Este deve ser o ID cadastrado no Mercos, e não o ID do seu sistema. |
     * | valor_faturado(obrigatório)   | Decimal: 9 dígitos, 2 casas decimais | Valor faturado do
     * pedido.                                                                  |
     * | data_faturamento(obrigatório) | String: “AAAA-MM-DD”                 | Data em que o
     * faturamento foi realizado.                                                   |
     * | numero_nf                     | String: 500                          | Número da nota
     * fiscal.                                                                     |
     * | informacoes_adicionais        | String: 500                          | Informações
     * adicionais referente ao faturamento.                                           |
     *
     * @param {double} id ID do Faturamento no sistema Mercos.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {AlterarFaturamentoDoPedidoRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static alterarFaturamentoDoPedido(id,
        contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/faturamento/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'AlterarFaturamentoDoPedido412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Obs.: Títulos vencidos excluídos não serão exibidos em tela para o usuário.
     * #### Estrutura de Retorno do GET
     * | Campo            | Tipo       | Descrição
     * |
     * |------------------|------------|----------------------------------------------------------
     * |
     * | id               | Integer    | Identificador único do título.
     * |
     * | numero_documento | String: 18 | Número de documento do título. Ex: “123456789012/123”.
     * |
     * | valor            | Double     | Valor do título. Valor máximo suportado: 9999999.99
     * |
     * | data_vencimento  | Date       | Data de vencimento do título. Ex.: 2015-11-22
     * |
     * | observacao       | String     | Observação do título.
     * |
     * | cliente_id       | Integer    | ID do cliente associado ao título.
     * |
     * | excluido         | Boolean    | Indica se o título está excluído.
     * |
     * | ultima_alteracao | DateTime   | Data e hora da última modificação deste título no Mercos
     * |
     *
     * @param {dateTime} alteradoApos Retorna os registros que foram alterados após esta data.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterTodasOsTTulosVencidos(alteradoApos,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/titulos_vencidos';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            alterado_apos: _apiHelper.stringifyDateTime(alteradoApos, 'date'),
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Obs.: Títulos vencidos excluídos não serão exibidos em tela para o usuário.
     * #### Estrutura de Retorno do GET
     * | Campo            | Tipo       | Descrição
     * |
     * |------------------|------------|----------------------------------------------------------
     * |
     * | id               | Integer    | Identificador único do título.
     * |
     * | numero_documento | String: 18 | Número de documento do título. Ex: “123456789012/123”.
     * |
     * | valor            | Double     | Valor do título. Valor máximo suportado: 9999999.99
     * |
     * | data_vencimento  | Date       | Data de vencimento do título. Ex.: 2015-11-22
     * |
     * | observacao       | String     | Observação do título.
     * |
     * | cliente_id       | Integer    | ID do cliente associado ao título.
     * |
     * | excluido         | Boolean    | Indica se o título está excluído.
     * |
     * | ultima_alteracao | DateTime   | Data e hora da última modificação deste título no Mercos
     * |
     *
     * @param {double} id ID do Titulo Vencido no sistema Mercos.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterUmTTuloVencido(id, contentType, applicationToken, companyToken, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/titulos_vencidos/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Obs.: Títulos vencidos excluídos não serão exibidos em tela para o usuário.
     * #### Estrutura de Retorno do GET
     * | Campo            | Tipo       | Descrição
     * |
     * |------------------|------------|----------------------------------------------------------
     * |
     * | id               | Integer    | Identificador único do título.
     * |
     * | numero_documento | String: 18 | Número de documento do título. Ex: “123456789012/123”.
     * |
     * | valor            | Double     | Valor do título. Valor máximo suportado: 9999999.99
     * |
     * | data_vencimento  | Date       | Data de vencimento do título. Ex.: 2015-11-22
     * |
     * | observacao       | String     | Observação do título.
     * |
     * | cliente_id       | Integer    | ID do cliente associado ao título.
     * |
     * | excluido         | Boolean    | Indica se o título está excluído.
     * |
     * | ultima_alteracao | DateTime   | Data e hora da última modificação deste título no Mercos
     * |
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {IncluirUmTTuloRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createIncluirUmTTulo(contentType, applicationToken, companyToken, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/titulos_vencidos';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'IncluirUmTTulo412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * Obs.: Títulos vencidos excluídos não serão exibidos em tela para o usuário.
     * #### Estrutura de Retorno do GET
     * | Campo            | Tipo       | Descrição
     * |
     * |------------------|------------|----------------------------------------------------------
     * |
     * | id               | Integer    | Identificador único do título.
     * |
     * | numero_documento | String: 18 | Número de documento do título. Ex: “123456789012/123”.
     * |
     * | valor            | Double     | Valor do título. Valor máximo suportado: 9999999.99
     * |
     * | data_vencimento  | Date       | Data de vencimento do título. Ex.: 2015-11-22
     * |
     * | observacao       | String     | Observação do título.
     * |
     * | cliente_id       | Integer    | ID do cliente associado ao título.
     * |
     * | excluido         | Boolean    | Indica se o título está excluído.
     * |
     * | ultima_alteracao | DateTime   | Data e hora da última modificação deste título no Mercos
     * |
     *
     * @param {double} id ID do Titulo Vencido no sistema Mercos.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {AlterarUmTTuloRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static alterarUmTTulo(id, contentType, applicationToken, companyToken, body, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/titulos_vencidos/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'PUT',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                let response = '';
                if (_context.response.body) {
                    response = JSON.parse(_context.response.body);
                }
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 412) {
                    const mappedObject = _baseController.getObjectMapper()
                        .mapObject(response, 'AlterarUmTTulo412ResponseException');
                    mappedObject.reason = 'Unexpected error in API call. See HTTP response body for details.';
                    mappedObject.context = _context;
                    const _err = { errorMessage: 'Unexpected error in API call. See HTTP response body for details.',
                        errorCode: 412,
                        errorResponse: mappedObject };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade Configuração de ICMS-ST é utilizada para se configurar o cálculo do ICMS-ST no
     * sistema Mercos. Para esta entidade não existe
     * a requisição de alteração *PUT*, caso tenha necessidade, deve ser deletado e incluído
     * novamente a regra.
     * Obs.: Configurações excluídas não serão exibidas em tela para o usuário.
     * #### Estrutura de Retorno do GET
     * | Campo               | Tipo       | Descrição
     * 
     * |
     * |---------------------|------------|-------------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * ---------------------------|
     * | id                  | Integer    | Identificador único
     * 
     * |
     * | codigo_ncm          | String: 20 | Código NCM (Nomenclatura Comum do Mercosul) que
     * identifica o(s) produto(s) sujeito(s) a esta configuração de ICMS-ST. Ex: “2201.10.00”.
     * |
     * | nome_excecao_fiscal | String: 20 | Exceção fiscal que identifica o(s) cliente(s)
     * sujeito(s) a esta configuração de ICMS-ST. Ex: “SIMPLES”.
     * |
     * | estado_destino      | String: 2  | Unidade da federação cujos clientes estão sujeitos a
     * esta configuração de ICMS-ST. Ex: “SC”.
     * |
     * | tipo_st             | String     | Determina a fórmula que será utilizada para calcular
     * a alíquota de ICMS-ST. Os valores válidos são “MVA” (Margem de Valor Agregado) e “PMC”
     * (Preço Máximo ao Consumidor).   |
     * | valor_mva           | Double     | A Margem de Valor Agregado (em percentual).
     * 
     * |
     * | valor_pmc           | Double     | A base de cálculo do ICMS-ST quando este é tributado
     * por PMC. Se houver redução de base ou qualquer outro fator incidente sobre a base já deve
     * ser considerado neste valor. |
     * | icms_credito        | Double     | Alíquota de ICMS de crédito (em percentual).
     * 
     * |
     * | icms_destino        | Double     | Alíquota de ICMS da UF de destino (em percentual).
     * 
     * |
     * | excluido            | Boolean    | Indica se a configuração está excluída.
     * 
     * |
     * | ultima_alteracao    | DateTime   | Data e hora da última modificação desta configuração
     * de ICMS-ST no Mercos.
     * |
     *
     * @param {dateTime} alteradoApos Retorna os registros que foram alterados após esta data.]
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterTodasAsConfiguraEsDeICMSST(alteradoApos,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/configuracoes_icms_st';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            alterado_apos: _apiHelper.stringifyDateTime(alteradoApos, 'date'),
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade Configuração de ICMS-ST é utilizada para se configurar o cálculo do ICMS-ST no
     * sistema Mercos. Para esta entidade não existe
     * a requisição de alteração *PUT*, caso tenha necessidade, deve ser deletado e incluído
     * novamente a regra.
     * Obs.: Configurações excluídas não serão exibidas em tela para o usuário.
     * #### Estrutura de Retorno do GET
     * | Campo               | Tipo       | Descrição
     * 
     * |
     * |---------------------|------------|-------------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * ---------------------------|
     * | id                  | Integer    | Identificador único
     * 
     * |
     * | codigo_ncm          | String: 20 | Código NCM (Nomenclatura Comum do Mercosul) que
     * identifica o(s) produto(s) sujeito(s) a esta configuração de ICMS-ST. Ex: “2201.10.00”.
     * |
     * | nome_excecao_fiscal | String: 20 | Exceção fiscal que identifica o(s) cliente(s)
     * sujeito(s) a esta configuração de ICMS-ST. Ex: “SIMPLES”.
     * |
     * | estado_destino      | String: 2  | Unidade da federação cujos clientes estão sujeitos a
     * esta configuração de ICMS-ST. Ex: “SC”.
     * |
     * | tipo_st             | String     | Determina a fórmula que será utilizada para calcular
     * a alíquota de ICMS-ST. Os valores válidos são “MVA” (Margem de Valor Agregado) e “PMC”
     * (Preço Máximo ao Consumidor).   |
     * | valor_mva           | Double     | A Margem de Valor Agregado (em percentual).
     * 
     * |
     * | valor_pmc           | Double     | A base de cálculo do ICMS-ST quando este é tributado
     * por PMC. Se houver redução de base ou qualquer outro fator incidente sobre a base já deve
     * ser considerado neste valor. |
     * | icms_credito        | Double     | Alíquota de ICMS de crédito (em percentual).
     * 
     * |
     * | icms_destino        | Double     | Alíquota de ICMS da UF de destino (em percentual).
     * 
     * |
     * | excluido            | Boolean    | Indica se a configuração está excluída.
     * 
     * |
     * | ultima_alteracao    | DateTime   | Data e hora da última modificação desta configuração
     * de ICMS-ST no Mercos.
     * |
     *
     * @param {double} id ID do ICMS-ST no sistema Mercos.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterUmaConfiguraODeICMSSTEspecFica(id,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/configuracoes_icms_st/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade Configuração de ICMS-ST é utilizada para se configurar o cálculo do ICMS-ST no
     * sistema Mercos. Para esta entidade não existe
     * a requisição de alteração *PUT*, caso tenha necessidade, deve ser deletado e incluído
     * novamente a regra.
     * Obs.: Configurações excluídas não serão exibidas em tela para o usuário.
     * #### Estrutura de Retorno do GET
     * | Campo               | Tipo       | Descrição
     * 
     * |
     * |---------------------|------------|-------------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * ---------------------------|
     * | id                  | Integer    | Identificador único
     * 
     * |
     * | codigo_ncm          | String: 20 | Código NCM (Nomenclatura Comum do Mercosul) que
     * identifica o(s) produto(s) sujeito(s) a esta configuração de ICMS-ST. Ex: “2201.10.00”.
     * |
     * | nome_excecao_fiscal | String: 20 | Exceção fiscal que identifica o(s) cliente(s)
     * sujeito(s) a esta configuração de ICMS-ST. Ex: “SIMPLES”.
     * |
     * | estado_destino      | String: 2  | Unidade da federação cujos clientes estão sujeitos a
     * esta configuração de ICMS-ST. Ex: “SC”.
     * |
     * | tipo_st             | String     | Determina a fórmula que será utilizada para calcular
     * a alíquota de ICMS-ST. Os valores válidos são “MVA” (Margem de Valor Agregado) e “PMC”
     * (Preço Máximo ao Consumidor).   |
     * | valor_mva           | Double     | A Margem de Valor Agregado (em percentual).
     * 
     * |
     * | valor_pmc           | Double     | A base de cálculo do ICMS-ST quando este é tributado
     * por PMC. Se houver redução de base ou qualquer outro fator incidente sobre a base já deve
     * ser considerado neste valor. |
     * | icms_credito        | Double     | Alíquota de ICMS de crédito (em percentual).
     * 
     * |
     * | icms_destino        | Double     | Alíquota de ICMS da UF de destino (em percentual).
     * 
     * |
     * | excluido            | Boolean    | Indica se a configuração está excluída.
     * 
     * |
     * | ultima_alteracao    | DateTime   | Data e hora da última modificação desta configuração
     * de ICMS-ST no Mercos.
     * |
     *
     * @param {double} id ID do ICMS-ST no sistema Mercos.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static deleteExcluirUmaConfiguraODeICMSST(id,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/configuracoes_icms_st/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'DELETE',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 400) {
                    const _err = { errorMessage: '', errorCode: 400, errorResponse: _response.body };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * A entidade Configuração de ICMS-ST é utilizada para se configurar o cálculo do ICMS-ST no
     * sistema Mercos. Para esta entidade não existe
     * a requisição de alteração *PUT*, caso tenha necessidade, deve ser deletado e incluído
     * novamente a regra.
     * Obs.: Configurações excluídas não serão exibidas em tela para o usuário.
     * #### Estrutura de Retorno do GET
     * | Campo               | Tipo       | Descrição
     * 
     * |
     * |---------------------|------------|-------------------------------------------------------
     * -------------------------------------------------------------------------------------------
     * ---------------------------|
     * | id                  | Integer    | Identificador único
     * 
     * |
     * | codigo_ncm          | String: 20 | Código NCM (Nomenclatura Comum do Mercosul) que
     * identifica o(s) produto(s) sujeito(s) a esta configuração de ICMS-ST. Ex: “2201.10.00”.
     * |
     * | nome_excecao_fiscal | String: 20 | Exceção fiscal que identifica o(s) cliente(s)
     * sujeito(s) a esta configuração de ICMS-ST. Ex: “SIMPLES”.
     * |
     * | estado_destino      | String: 2  | Unidade da federação cujos clientes estão sujeitos a
     * esta configuração de ICMS-ST. Ex: “SC”.
     * |
     * | tipo_st             | String     | Determina a fórmula que será utilizada para calcular
     * a alíquota de ICMS-ST. Os valores válidos são “MVA” (Margem de Valor Agregado) e “PMC”
     * (Preço Máximo ao Consumidor).   |
     * | valor_mva           | Double     | A Margem de Valor Agregado (em percentual).
     * 
     * |
     * | valor_pmc           | Double     | A base de cálculo do ICMS-ST quando este é tributado
     * por PMC. Se houver redução de base ou qualquer outro fator incidente sobre a base já deve
     * ser considerado neste valor. |
     * | icms_credito        | Double     | Alíquota de ICMS de crédito (em percentual).
     * 
     * |
     * | icms_destino        | Double     | Alíquota de ICMS da UF de destino (em percentual).
     * 
     * |
     * | excluido            | Boolean    | Indica se a configuração está excluída.
     * 
     * |
     * | ultima_alteracao    | DateTime   | Data e hora da última modificação desta configuração
     * de ICMS-ST no Mercos.
     * |
     *
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     * @param {IncluirUmaConfiguraODeICMSSTRequest} body TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static createIncluirUmaConfiguraODeICMSST(contentType,
        applicationToken,
        companyToken,
        body,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/configuracoes_icms_st';
        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'content-type': 'application/json; charset=utf-8',
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'POST',
            headers: _headers,
            body: _apiHelper.jsonSerialize(body),
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else if (_response.statusCode === 400) {
                    const _err = { errorMessage: '', errorCode: 400, errorResponse: _response.body };
                    _callback(_err, null, _context);
                    _reject(_err);
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * #### Estrutura de Retorno das promoções.
     * | Campo               | Tipo       | Descrição
     * 
     * |
     * |---------------------|------------|-------------------------------------------------------
     * --------------------------|
     * | id                  | Integer    | Identificador único.
     * |
     * | representada_id     | Integer    | Identificador único da representada.
     * |
     * | nome                | String     | Nome da promoção.
     * |
     * | excluido            | boolean    | Indica se a promoção está excluída.
     * |
     * | regras              | List       | Lista contendo os ids das regras desta promoção :
     * ```[{"id_regra": Integer}]``` |
     * | ultima_alteracao    | DateTime   | Data e hora da última modificação desta promoção.
     * |
     *
     * @param {dateTime} alteradoApos Retorna os registros que foram alterados após esta data.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterTodasAsPromoEs(alteradoApos,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/promocoes';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            alterado_apos: _apiHelper.stringifyDateTime(alteradoApos, 'date'),
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * #### Estrutura de Retorno das promoções.
     * | Campo               | Tipo       | Descrição
     * 
     * |
     * |---------------------|------------|-------------------------------------------------------
     * --------------------------|
     * | id                  | Integer    | Identificador único.
     * |
     * | representada_id     | Integer    | Identificador único da representada.
     * |
     * | nome                | String     | Nome da promoção.
     * |
     * | excluido            | boolean    | Indica se a promoção está excluída.
     * |
     * | regras              | List       | Lista contendo os ids das regras desta promoção :
     * ```[{"id_regra": Integer}]``` |
     * | ultima_alteracao    | DateTime   | Data e hora da última modificação desta promoção.
     * |
     *
     * @param {double} id ID da promoção no sistema Mercos.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterUmaPromoO(id, contentType, applicationToken, companyToken, callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/promocoes/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * #### Estrutura de Retorno das políticas comerciais.
     * | Campo               | Tipo       | Descrição
     * 
     * |
     * |---------------------|------------|-------------------------------------------------------
     * ------------------------------------|
     * | id                  | Integer    | Identificador único.
     * |
     * | representada_id     | Integer    | Identificador único da representada.
     * |
     * | nome                | String     | Nome da política comercial.
     * |
     * | excluido            | boolean    | Indica se a política comercial está excluída.
     * |
     * | ativo               | boolean    | Indica se a política comercial está ativa.
     * |
     * | ordem               | Integer    | Indica a ordem da política comercial.
     * |
     * | regras              | List       | Lista contendo os ids das regras desta política
     * comercial : ```[{"id_regra": Integer}]``` |
     * | ultima_alteracao    | DateTime   | Data e hora da última modificação desta política
     * comercial.                               |
     *
     * @param {dateTime} alteradoApos Retorna os registros que foram alterados após esta data.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterTodasAsPolTicasComerciais(alteradoApos,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        const _pathUrl = '/v1/politicas_comerciais';
        let _queryBuilder = `${_baseUri}${_pathUrl}`;

        // process query parameters
        _queryBuilder = _apiHelper.appendUrlWithQueryParameters(_queryBuilder, {
            alterado_apos: _apiHelper.stringifyDateTime(alteradoApos, 'date'),
        });

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
    /**
     * #### Estrutura de Retorno das políticas comerciais.
     * | Campo               | Tipo       | Descrição
     * 
     * |
     * |---------------------|------------|-------------------------------------------------------
     * ------------------------------------|
     * | id                  | Integer    | Identificador único.
     * |
     * | representada_id     | Integer    | Identificador único da representada.
     * |
     * | nome                | String     | Nome da política comercial.
     * |
     * | excluido            | boolean    | Indica se a política comercial está excluída.
     * |
     * | ativo               | boolean    | Indica se a política comercial está ativa.
     * |
     * | ordem               | Integer    | Indica a ordem da política comercial.
     * |
     * | regras              | List       | Lista contendo os ids das regras desta política
     * comercial : ```[{"id_regra": Integer}]``` |
     * | ultima_alteracao    | DateTime   | Data e hora da última modificação desta política
     * comercial.                               |
     *
     * @param {double} id ID da política comercial no sistema Mercos.
     * @param {string} contentType TODO: type description here
     * @param {string} applicationToken TODO: type description here
     * @param {string} companyToken TODO: type description here
     *
     * @callback    The callback function that returns response from the API call
     *
     * @returns {Promise}
     */
    static getObterUmaPolTicaComercial(id,
        contentType,
        applicationToken,
        companyToken,
        callback) {
        // create empty callback if absent
        const _callback = typeof callback === 'function' ? callback : () => undefined;

        // prepare query string for API call
        const _baseUri = _configuration.BASEURI;

        let _pathUrl = '/v1/politicas_comerciais/{id}';
        // process template parameters
        _pathUrl = _apiHelper.appendUrlWithTemplateParameters(_pathUrl, {
            id,
        });

        const _queryBuilder = `${_baseUri}${_pathUrl}`;

        // validate and preprocess url
        const _queryUrl = _apiHelper.cleanUrl(_queryBuilder);

        // prepare headers
        const _headers = {
            'Content-Type': contentType,
            ApplicationToken: applicationToken,
            CompanyToken: companyToken,
            'user-agent': 'APIMATIC 2.0',
        };

        // construct the request
        const _options = {
            queryUrl: _queryUrl,
            method: 'GET',
            headers: _headers,
        };

        // build the response processing.
        return new Promise((_fulfill, _reject) => {
            _request(_options, (_error, _response, _context) => {
                let errorResponse;
                if (_error) {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                } else if (_response.statusCode >= 200 && _response.statusCode <= 206) {
                    _callback(null, null, _context);
                    _fulfill();
                } else {
                    errorResponse = _baseController.validateResponse(_context);
                    _callback(errorResponse.error, errorResponse.response, errorResponse.context);
                    _reject(errorResponse.error);
                }
            });
        });
    }
}
module.exports = APIController;
